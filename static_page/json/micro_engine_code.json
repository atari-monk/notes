{
  "sections": [
    {
      "title": "Entity",
      "chats": [
        {
          "indexTitle": "__EntityBase",
          "question": "__EntityBase",
          "answer": "* Entity part of Entity Component System in game engine  \n* It has string id and stores components of game object that i call Entity  \n```plaintext\n|-- engine_api/\n|   |-- src/\n|       |-- ecs\n|           |-- entity\n|               |-- IEntity.ts\n|               |-- IEntityWithComponents.ts\n|               |-- IRenderable.ts\n|               |-- IUpdatable.ts\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs\n|           |-- entity\n|               |-- Entity.ts\n```\n```typescript\nimport IEntityWithComponents from './IEntityWithComponents'\n\nexport default interface IEntity extends IEntityWithComponents {\n  id: string\n}\n```\n```typescript\nimport { ClassType } from '../../tech/entity_component/ClassType'\nimport IComponent from '../../tech/entity_component/IComponent'\nimport IRenderable from './IRenderable'\nimport IUpdatable from './IUpdatable'\n\nexport default interface IEntityWithComponents extends IUpdatable, IRenderable {\n  addComponent(component: IComponent): void\n  addComponents(components: IComponent[]): void\n  getComponentStrict<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T\n  getComponent<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T | undefined\n}\n```\n```typescript\nexport default interface IRenderable {\n  render(deltaTime: number): void\n}\n```\n```typescript\nexport default interface IUpdatable {\n  update(deltaTime: number): void\n}\n```\n```typescript\nimport {\n  ClassType,\n  IComponent,\n  IEntity,\n  IEntityWithComponents,\n} from 'engine_api'\n\nexport default class Entity implements IEntityWithComponents, IEntity {\n  private _components = new Map<ClassType<IComponent>, IComponent[]>()\n  private _id!: string\n\n  get id(): string {\n    return this._id\n  }\n\n  set id(id: string) {\n    this._id = id\n  }\n\n  addComponent(component: IComponent): void {\n    this.addComponentToEntity(component)\n  }\n\n  addComponents(components: IComponent[]): void {\n    for (const component of components) {\n      this.addComponentToEntity(component)\n    }\n  }\n\n  private addComponentToEntity(component: IComponent) {\n    const componentType = component.constructor as ClassType<IComponent>\n\n    if (!this._components.has(componentType)) {\n      this._components.set(componentType, [component])\n    } else {\n      this._components.get(componentType)!.push(component)\n    }\n  }\n\n  getComponent<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T | undefined {\n    const components = this._components.get(componentType)\n\n    if (components) {\n      if (id) {\n        return components.find((item) => item.id === id) as T | undefined\n      } else {\n        return components[0] as T | undefined\n      }\n    }\n\n    return undefined\n  }\n\n  getComponentStrict<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T {\n    const components = this._components.get(componentType)\n    const errorMessage = (id?: string) =>\n      id\n        ? `Component of type ${componentType.name} and id ${id} not found.`\n        : `No components of type ${componentType.name} found.`\n    if (components) {\n      if (id) {\n        const component = components.find((item) => item.id === id) as\n          | T\n          | undefined\n\n        if (component) {\n          return component\n        } else {\n          throw new Error(errorMessage(id))\n        }\n      } else {\n        const firstComponent = components[0] as T | undefined\n\n        if (firstComponent) {\n          return firstComponent\n        } else {\n          throw new Error(errorMessage())\n        }\n      }\n    } else {\n      throw new Error(errorMessage())\n    }\n  }\n\n  update(deltaTime: number): void {\n    for (const componentArrays of this._components.values()) {\n      for (const component of componentArrays) {\n        component.update(deltaTime)\n      }\n    }\n  }\n\n  render(deltaTime: number): void {\n    for (const componentArrays of this._components.values()) {\n      for (const component of componentArrays) {\n        component.render(deltaTime)\n      }\n    }\n  }\n}\n```",
          "dateTime": "2024-02-08T23:27:01.338Z"
        }
      ]
    },
    {
      "title": "Component",
      "chats": [
        {
          "indexTitle": "__ComponentBase",
          "question": "__ComponentBase",
          "answer": "* Named Component  \n* Component part of Entity Component System in game engine  \n* This type defines data model and content of Entity  \n```plaintext\n|-- engine_api/\n|   |-- src/\n|       |-- ecs/\n|           |-- component/\n|               |-- ClassType.ts\n|               |-- IComponent.ts\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- component/\n|               |-- Component.ts\n```\n```typescript\nexport type ClassType<T> = abstract new (...args: any[]) => T\n```\n```typescript\nexport default interface IComponent {\n  update(deltaTime: number): void\n  render(deltaTime: number): void\n  get id(): string\n  set id(id: string)\n}\n```\n```typescript\nimport { IComponent } from 'engine_api'\n\nexport default abstract class Component implements IComponent {\n  private _id!: string\n\n  get id(): string {\n    return this._id\n  }\n\n  set id(id: string) {\n    this._id = id\n  }\n\n  update(_deltaTime: number) {}\n\n  render(_deltaTime: number) {}\n}\n```\n```typescript\nimport { IBoxCollider, IVector2 } from 'engine_api'\nimport Vector2 from '../../math/vector/Vector2'\nimport Collider from './base/Collider'\n\nexport default class BoxCollider extends Collider implements IBoxCollider {\n  private _size: IVector2 = new Vector2()\n  private _halfSize: IVector2 = new Vector2()\n\n  public get size(): IVector2 {\n    return this._size\n  }\n\n  public set size(size: IVector2) {\n    this._size = size\n    this._halfSize.x = this._size.x / 2\n    this._halfSize.y = this._size.y / 2\n  }\n\n  public get halfSize(): IVector2 {\n    return this._halfSize\n  }\n}\n```\n```typescript\nimport { ICircleCollider } from 'engine_api'\nimport Collider from './base/Collider'\n\nexport default class CircleCollider\n  extends Collider\n  implements ICircleCollider\n{\n  private _radius: number = 100\n\n  public get radius(): number {\n    return this._radius\n  }\n\n  public set radius(radius: number) {\n    this._radius = radius\n  }\n}\n```\n```typescript\nimport { InputDto } from 'engine_api'\nimport Component from './base/Component'\n\nexport default class ClientMovement extends Component {\n  private readonly _inputDto: InputDto = new InputDto()\n\n  get inputDto(): InputDto {\n    return this._inputDto\n  }\n}\n```\n```typescript\nimport { ICollisionObject } from 'engine_api'\nimport Component from './base/Component'\n\nexport default class CollisionObject\n  extends Component\n  implements ICollisionObject\n{\n  private _objectIdToCollideWith!: string\n\n  set objectIdToCollideWith(objectId: string) {\n    this._objectIdToCollideWith = objectId\n  }\n\n  get objectIdToCollideWith(): string {\n    return this._objectIdToCollideWith\n  }\n}\n```\n```typescript\nimport { ICollisionInfo, IScoreInfo, IVector2 } from 'engine_api'\nimport Component from './base/Component'\nimport { IGameState } from 'engine_api'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport default class GameState extends Component implements IGameState {\n  private _lastCollisionInfo: ICollisionInfo = {} as ICollisionInfo\n  private _score: IScoreInfo = { redScore: 0, blueScore: 0 } as IScoreInfo\n  private _position: IVector2 = new Vector2()\n\n  public get lastCollisionInfo(): ICollisionInfo {\n    return this._lastCollisionInfo\n  }\n\n  public set lastCollisionInfo(lastCollisionInfo: ICollisionInfo) {\n    this._lastCollisionInfo = lastCollisionInfo\n  }\n\n  public get score(): IScoreInfo {\n    return this._score\n  }\n\n  public set score(score: IScoreInfo) {\n    this._score = score\n  }\n\n  public get position(): IVector2 {\n    return this._position\n  }\n\n  public set position(position: IVector2) {\n    this._position = position\n  }\n}\n```\n```typescript\nimport BoxCollider from './BoxCollider'\n\nexport default class InsideBoxCollider extends BoxCollider {}\n```\n```typescript\nimport Vector2 from '../../math/vector/Vector2'\nimport { ILimitMove, IVector2 } from 'engine_api'\nimport Collider from './base/Collider'\n\nexport default class LimitMove extends Collider implements ILimitMove {\n  private _limitSize: IVector2 = new Vector2()\n\n  public get limitSize(): IVector2 {\n    return this._limitSize\n  }\n\n  public set limitSize(limitSize: IVector2) {\n    this._limitSize = limitSize\n  }\n}\n```",
          "dateTime": "2024-02-08T23:31:08.894Z"
        }
      ]
    },
    {
      "title": "System",
      "chats": [
        {
          "indexTitle": "__SystemBase",
          "question": "__SystemBase",
          "answer": "```plaintext\n|-- engine_api/\n|   |-- src/\n|       |-- ecs/\n|           |-- system/\n|               |-- ISystem.ts\n|        |-- IStartable .ts\n|        |-- IUpdateable .ts\n```\n```typescript\nexport default interface IStartable {\n  start(): void\n}\n```\n```typescript\nexport default interface IUpdateable {\n  update(deltaTime: number): void\n}\n```\n```typescript\nimport IStartable from '../IStartable'\nimport IUpdateable from '../IUpdateable'\n\nexport default interface ISystem extends IStartable, IUpdateable {}\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- system/\n|               |-- base/\n|                   |-- IRegisterEntityById.ts\n|                   |-- ISystemManager.ts\n|                   |-- SystemBase.ts\n|                   |-- SystemManager.ts\n```\n```typescript\nexport default interface IRegisterEntityById {\n  registerEntityById(entityId: string): void\n}\n```\n```typescript\nimport { IManager, ISystem, IUpdateable } from 'engine_api'\n\nexport default interface ISystemManager\n  extends IUpdateable,\n    IManager<ISystem> {}\n```\n```typescript\nimport { IEntity, IStartable, IManager, IUpdateable } from 'engine_api'\nimport IRegisterEntityById from './IRegisterEntityById'\n\nexport default abstract class SystemBase\n  implements IStartable, IUpdateable, IRegisterEntityById\n{\n  protected _entity!: IEntity\n\n  constructor(protected readonly _entityManager: IManager<IEntity>) {}\n\n  registerEntityById(entityId: string): void {\n    this._entity = this._entityManager.getStrict(entityId)\n  }\n\n  start() {}\n\n  update(_deltaTime: number) {}\n}\n```\n```typescript\nimport { ISystem } from 'engine_api'\nimport ISystemManager from './ISystemManager'\nimport MapManager from '../../entity/manager/MapManager'\n\nexport default class SystemManager\n  extends MapManager<ISystem>\n  implements ISystemManager\n{\n  update(deltaTime: number): void {\n    for (const system of this.values()) {\n      system.update(deltaTime)\n    }\n  }\n}\n```",
          "dateTime": "2024-02-08T22:53:30.503Z"
        },
        {
          "indexTitle": "PlayerKick",
          "question": "PlayerKick",
          "answer": "```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- system/\n|               |-- PlayerKick.ts\n```\n```typescript\nimport { IEntity, IEntityManager, IEventSystem } from 'engine_api'\nimport { KeyboardEvent, KeyboardKeys } from './keyboard/keyboardTypes'\nimport SystemBase from './base/SystemBase'\nimport IKeyboardEventData from './keyboard/IKeyboardEventData'\nimport RigidBody from '../component/RigidBody'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport default class PlayerKick extends SystemBase {\n  protected _ball!: IEntity\n  private ball_rb!: RigidBody\n  private player_rb!: RigidBody\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super(entityManager)\n    this._eventSystem.subscribe(KeyboardEvent, this.kick.bind(this))\n  }\n\n  registerBallById(entityId: string): void {\n    this._ball = this._entityManager.getStrict(entityId)\n  }\n\n  start(): void {\n    this.ball_rb = this._ball.getComponentStrict(RigidBody)\n    this.player_rb = this._entity.getComponentStrict(RigidBody)\n  }\n\n  private kick(data: IKeyboardEventData) {\n    if (data.key !== KeyboardKeys.z) return\n    console.log('handleZKey')\n    const vn = Vector2.getNew(this.player_rb.velocity).normalize()\n    this.ball_rb.velocity = vn.multiply(250)\n    console.log(this.ball_rb.velocity)\n  }\n}\n```",
          "dateTime": "2024-02-08T22:59:08.234Z"
        },
        {
          "indexTitle": "__InitLogicSystem",
          "question": "__InitLogicSystem",
          "answer": "* System part of Entity Component System in game engine  \n* Api for specific type of system base \n* Preforms initialization tasks on registered entities  \n* Used as base in initialization systems  \n  invoked after entities are created from data   \n  and need initialization and integration with engine  \n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- component/\n|           |-- entity/\n|           |-- system/\n|               |-- base/\n|                   |-- init_logic/\n|                       |-- IInitLogicSystem.ts\n|                       |-- IInitLogicSystemManager.ts\n|                       |-- InitLogicSystemBase.ts\n|                       |-- InitLogicSystemManager.ts\n```\n```typescript\nexport default interface IRegisterEntityByName {\n  registerEntityByName(name: string): void\n}\n```\n```typescript\nimport IRegisterEntityByName from '../IRegisterEntityByName'\n\nexport default interface IInitLogicSystem extends IRegisterEntityByName {\n  init(): void\n}\n```\n* System Api  \n```typescript\nimport { IManager } from 'engine_api'\nimport IInitLogicSystem from './IInitLogicSystem'\n\nexport default interface IInitLogicSystemManager\n  extends IManager<IInitLogicSystem> {\n  init(): void\n}\n```\n* Systems container api  \n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport IInitLogicSystem from './IInitLogicSystem'\n\nexport default abstract class InitLogicSystemBase implements IInitLogicSystem {\n  protected _entityList: IEntity[] = []\n\n  constructor(protected readonly _entityManager: IEntityManager) {}\n\n  init(): void {\n    this.iterateEntities((entity) => this.initLogic(entity))\n  }\n\n  private iterateEntities(callback: (entity: IEntity) => void): void {\n    for (const entity of this._entityList) {\n      callback(entity)\n    }\n  }\n\n  abstract initLogic(entity: IEntity): void\n\n  registerEntityByName(name: string): void {\n    this._entityList.push(this._entityManager.getStrict(name))\n  }\n}\n```\n* Base class  \n* Stores registered entities  \n* Preforms init logic on them  \n* Child classes must override initLogic method   \n  to define their init logic and run it on each registered entity  \n```typescript\nimport MapManager from '../../../../tech/entity_component/MapManager'\nimport IInitLogicSystem from './IInitLogicSystem'\nimport IInitLogicSystemManager from './IInitLogicSystemManager'\n\nexport default class InitLogicSystemManager\n  extends MapManager<IInitLogicSystem>\n  implements IInitLogicSystemManager\n{\n  init(): void {\n    for (const system of this.values()) {\n      system.init()\n    }\n  }\n}\n```\n* Init systems container  \n* Stores evry init system in engine  \n* Runs all of them  \n\n\n",
          "dateTime": "2024-02-08T23:08:40.284Z"
        },
        {
          "indexTitle": "__KeyboardMappingSystem",
          "question": "KeyboardMappingSystem",
          "answer": "* System in ecs  \n* Mapping keyboard keys to events  \n```plaintext\n|-- engine_api/\n|   |-- src/\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |--ecs\n|           |--system\n|               |--keyboard\n|                   |--KeyboardMappingSubSystem.ts\n|                   |--KeyboardMappingSystem.ts\n|                   |--keyboardTypes.ts\n```\n```typescript\nexport type KeyAction = () => void\n\nexport type KeyActionMap = { [key: string]: KeyAction }\n\nexport type KeyEvent = 'KeyDown' | 'KeyUp'\n\nexport const KeyEvents: { [key in KeyEvent]: key } = {\n  KeyDown: 'KeyDown',\n  KeyUp: 'KeyUp',\n}\n\nexport type KeyActionWithParam<T> = (data: T) => void\n\nexport type KeyActionWithParamMap<T> = { [key: string]: KeyActionWithParam<T> }\n\nexport const KeyboardEvent = 'KeyboardEvent'\n\nexport type KeyboardKey = 'q' | 'e' | 'z' | 'x'\n\nexport const KeyboardKeys: { [key in KeyboardKey]: key } = {\n  q: 'q',\n  e: 'e',\n  z: 'z',\n  x: 'x',\n}\n```\n```typescript\nimport { KeyboardKey } from './keyboardTypes'\n\nexport default interface IKeyboardEventData {\n  entityId: string\n  key: KeyboardKey\n}\n```\n```typescript\nimport { IEntity } from 'engine_api'\n\nexport default interface IKeyboardMappingSubSystem {\n  subscribeInput(entity: IEntity): void\n  unsubscribeInput(): void\n}\n```\n```typescript\nimport { IInputManager, IEventSystem, IEntity } from 'engine_api'\nimport {\n  KeyActionWithParamMap,\n  KeyEvents,\n  KeyboardEvent,\n  KeyboardKeys,\n} from './keyboardTypes'\nimport IKeyboardMappingSubSystem from './IKeyboardMappingSubSystem'\nimport IKeyboardEventData from './IKeyboardEventData'\n\nexport default class KeyboardMappingSubSystem\n  implements IKeyboardMappingSubSystem\n{\n  private _keyActions: KeyActionWithParamMap<string>\n  private _keyDownCallback!: (key: string) => void\n\n  constructor(\n    private readonly _inputManager: IInputManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    this._keyActions = this.initKeyAction()\n  }\n\n  private initKeyAction() {\n    return {\n      q: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.q,\n        } as IKeyboardEventData),\n      e: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.e,\n        } as IKeyboardEventData),\n      z: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.z,\n        } as IKeyboardEventData),\n      x: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.x,\n        } as IKeyboardEventData),\n    } as KeyActionWithParamMap<string>\n  }\n\n  subscribeInput(entity: IEntity): void {\n    this._keyDownCallback = (inputKey: string) => {\n      const key = inputKey.toLowerCase()\n      if (this.isKeyMapped(key)) return\n      this._keyActions[key](entity.id)\n    }\n\n    this._inputManager.subscribeInputEvent(\n      KeyEvents.KeyDown,\n      this._keyDownCallback\n    )\n  }\n\n  unsubscribeInput() {\n    this._inputManager.unsubscribeInputEvent(\n      KeyEvents.KeyDown,\n      this._keyDownCallback\n    )\n  }\n\n  private isKeyMapped(key: string) {\n    return !this._keyActions.hasOwnProperty(key)\n  }\n}\n```\n```typescript\nimport { IFactory, IInputManager, IEventSystem } from 'engine_api'\nimport IKeyboardMappingSubSystem from './IKeyboardMappingSubSystem'\nimport KeyboardMappingSubSystem from './KeyboardMappingSubSystem'\n\nexport default class KeyboardMappingSubSystemFactory\n  implements IFactory<IKeyboardMappingSubSystem>\n{\n  constructor(\n    private readonly _input: IInputManager,\n    private readonly _eventSystem: IEventSystem\n  ) {}\n\n  create(): IKeyboardMappingSubSystem {\n    return new KeyboardMappingSubSystem(this._input, this._eventSystem)\n  }\n}\n```\n```typescript\nimport { IEntityManager, IEntity, IManager, IFactory } from 'engine_api'\nimport InitLogicSystemBase from '../base/init_logic/InitLogicSystemBase'\nimport IKeyboardMappingSubSystem from './IKeyboardMappingSubSystem'\nimport MapManager from '../../entity/manager/MapManager'\n\nexport default class KeyboardMappingSystem extends InitLogicSystemBase {\n  private _subSystemManager: IManager<IKeyboardMappingSubSystem> =\n    new MapManager<IKeyboardMappingSubSystem>()\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _subSystemFactory: IFactory<IKeyboardMappingSubSystem>\n  ) {\n    super(entityManager)\n  }\n\n  initLogic(entity: IEntity): void {\n    const subSystem = this._subSystemFactory.create()\n    subSystem.subscribeInput(entity)\n    this._subSystemManager.add(entity.id, subSystem)\n  }\n\n  unsubscribe(entity: IEntity) {\n    const subSystem = this._subSystemManager.getStrict(entity.id)\n    subSystem.unsubscribeInput()\n  }\n}\n```\n* GameSystemBuilder, use it in SinglePlayerBuilder->withSystems()\n```typescript\nwithKeyboardMapping() {\n    const system = new KeyboardMappingSystem(\n      this._entityManager,\n      new KeyboardMappingSubSystemFactory(\n        this._engine.input,\n        this._engine.eventSystem\n      )\n    )\n\n    const { player1, player2 } = this._entityList\n    ;[player1, player2].forEach((entity) => {\n      system.registerEntityByName(entity.id)\n    })\n\n    this._engine.initLogicSystemManager.add('keyboardmapping', system)\n    return this\n  }\n```",
          "dateTime": "2024-02-08T23:14:12.971Z"
        }
      ]
    },
    {
      "title": "Data Loaders",
      "chats": [
        {
          "indexTitle": "Entity Loader v2",
          "question": "Entity Loader v2",
          "answer": "```typescript\nexport const componentList: Record<string, string> = {\n  transform: 'transform',\n  boxCollider: 'boxCollider',\n  sprite: 'sprite',\n  rigidBody: 'rigidBody',\n}\n```\n```typescript\nimport { BoxCollider, RigidBody, Sprite, Transform, Vector2 } from 'engine'\nimport { IBoxCollider, IRigidBody, ISprite, ITransform } from 'engine_api'\nimport IComponentMapper from './IComponentMapper'\n\nexport default class ComponentMapper implements IComponentMapper {\n  builders: Record<string, (data: any) => any> = {\n    transform: this.mapTransform,\n    boxCollider: this.mapBoxCollider,\n    sprite: this.mapSprite,\n    rigidBody: this.mapRigidBody,\n  }\n\n  private mapTransform(data: ITransform) {\n    console.log('Building transform')\n    const d = data\n    const c = new Transform()\n    c.position = d.position\n    c.rotation = d.rotation\n    c.scale = d.scale\n    return c\n  }\n\n  private mapBoxCollider(data: IBoxCollider) {\n    console.log('Building boxCollider')\n    const d = data\n    const c = new BoxCollider()\n    c.center = d.center\n    c.color = d.color\n    c.enableRender = d.enableRender\n    c.isTrigger = d.isTrigger\n    c.material = d.material\n    c.size = d.size\n    return c\n  }\n\n  private mapSprite(data: ISprite) {\n    console.log('Building sprite')\n    const d = data\n    const c = new Sprite()\n    c.spriteOffset = d.spriteOffset\n    c.isFlipped = d.isFlipped\n    c.spriteAnimation = d.spriteAnimation\n    c.state = d.state\n    return c\n  }\n\n  private mapRigidBody(data: IRigidBody) {\n    console.log('Building rigidBody')\n    const d = data\n    const c = new RigidBody()\n    //todo test this:\n    //c.velocity = d.velocity\n    c.velocity = Vector2.getNew(d.velocity)\n    c.mass = d.mass\n    c.cor = d.cor\n    c.speedMultiplier = d.speedMultiplier\n    c.maxSpeed = d.maxSpeed\n    c.moveStep = d.moveStep\n    c.useArrowKeys = d.useArrowKeys\n    c.stopThreshold = d.stopThreshold\n    return c\n  }\n}\n```\n```typescript\nimport { IEntity, IManager } from 'engine_api'\n\nexport default class DataPrinter {\n  printData(data: Record<string, any>) {\n    console.log('Printing file data:')\n    console.log('Data Type:', typeof data)\n    console.log('Loaded Data:', data)\n  }\n\n  printKeysAndValues(data: Record<string, any>) {\n    console.log('Printing keys and values:')\n    for (const key in data) {\n      if (data.hasOwnProperty(key)) {\n        console.log('Key:', key)\n        console.log('Item:', data[key])\n      }\n    }\n  }\n\n  printValues(data: Record<string, any>) {\n    console.log('Printing values:')\n    const values = Object.values(data)\n    for (const item of values) {\n      console.log('Item:', item)\n    }\n  }\n\n  printEntity(manager: IManager<IEntity>) {\n    manager.forEach((key, entity) => console.log(key, ':', entity))\n  }\n}\n```\n```typescript\nimport { Entity, MapManager } from 'engine'\nimport { IEntity } from 'engine_api'\nimport IComponentMapper from './IComponentMapper'\nimport { componentList } from './componentList'\n\nexport default class EntityComponentCreator {\n  constructor(private readonly _componentBuilder: IComponentMapper) {}\n\n  createEntityManager(data: { [key: string]: Record<string, any> }) {\n    const entityManager = new MapManager<IEntity>()\n    for (const key in data) {\n      const entity = new Entity()\n      entity.id = key\n      entityManager.add(key, entity)\n      this.createEntityComponents(data[key], entity)\n    }\n    return entityManager\n  }\n\n  private createEntityComponents(data: Record<string, any>, entity: IEntity) {\n    for (const key in data) {\n      const componentType = componentList[key]\n      if (componentType) {\n        const componentBuild = this._componentBuilder.builders[componentType](\n          data[key]\n        )\n        if (componentBuild) entity.addComponent(componentBuild)\n        else console.warn(`Unsupported builder for component type: ${key}`)\n      } else console.warn(`Unsupported component type: ${key}`)\n    }\n  }\n}\n```\n```typescript\nimport ComponentMapper from './ComponentMapper'\nimport DataPrinter from './DataPrinter'\nimport EntityComponentCreator from './EntityComponentCreator'\nimport FileLoader from './FileLoader'\n\nexport default class EntityManagerInitializer {\n  private isDataPrintOn: boolean\n  private fileLoader: FileLoader\n  private data: any // Assuming the type of data, adjust as needed\n  private printer: DataPrinter\n  private entityManager: any // Adjust the type according to your EntityManager\n\n  constructor(isDataPrintOn: boolean) {\n    this.isDataPrintOn = isDataPrintOn\n    this.fileLoader = new FileLoader('./data/entityFormat.json')\n    this.data = null\n    this.printer = new DataPrinter()\n    this.entityManager = null\n  }\n\n  async initialize(): Promise<void> {\n    this.data = await this.fileLoader.getData()\n\n    if (this.isDataPrintOn) {\n      this.printData()\n      this.printKeysAndValues()\n      this.printValues()\n    }\n\n    this.initializeEntityManager()\n    this.printEntity()\n  }\n\n  private printData(): void {\n    this.printer.printData(this.data)\n  }\n\n  private printKeysAndValues(): void {\n    this.printer.printKeysAndValues(this.data)\n  }\n\n  private printValues(): void {\n    this.printer.printValues(this.data)\n  }\n\n  private initializeEntityManager(): void {\n    const entityComponentCreator = new EntityComponentCreator(\n      new ComponentMapper()\n    )\n    this.entityManager = entityComponentCreator.createEntityManager(this.data)\n  }\n\n  private printEntity(): void {\n    this.printer.printEntity(this.entityManager)\n  }\n}\n\nexport async function testEntityBuildingFromJsonData() {\n  const isDataPrintOn: boolean = false\n  const entityManagerInitializer = new EntityManagerInitializer(isDataPrintOn)\n  await entityManagerInitializer.initialize()\n}\n```\n```typescript\nimport { JsonObjectLoader } from 'engine'\n\nexport default class FileLoader {\n  constructor(private readonly _filePath: string) {}\n\n  async getData(): Promise<Record<string, any>> {\n    const dataLoader = new JsonObjectLoader<Record<string, any>>(this._filePath)\n    try {\n      return await dataLoader.getData()\n    } catch (error) {\n      console.error('Error getting data:', error)\n      throw error\n    }\n  }\n}\n```\n```typescript\nexport default interface IComponentMapper {\n  builders: Record<string, (data: any) => any>\n}\n```",
          "dateTime": "2024-02-08T23:22:39.608Z"
        }
      ]
    }
  ]
}