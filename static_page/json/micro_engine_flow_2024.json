{
  "sections": [
    {
      "title": "Rules",
      "chats": [
        {
          "indexTitle": "Rules of this document",
          "question": "Rules of this document",
          "answer": "Put task 'Task X.' as a section.  \nTask coresponds to task in micro_engine_task_2024 document.  \nThen add to this section.  \nAdd classes that where coded in task.  \nJust their code with optional description.  \nPoint of this document is to visualize code changes during task.\n",
          "dateTime": "2024-01-03T10:35:28.189Z"
        },
        {
          "indexTitle": "Template",
          "question": "Template",
          "answer": "```markdown\n\\```typescript\n\\```\n```",
          "dateTime": "2024-01-04T12:23:06.000Z"
        }
      ]
    },
    {
      "title": "Task 30.",
      "chats": [
        {
          "indexTitle": "MovementComponent",
          "question": "MovementComponent",
          "answer": "```typescript\nimport { IEventSystem, IInputManager, IObject } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport Vector2 from '../../math/vector/Vector2'\n\ntype KeyAction = () => void\n\nexport default class MovementComponent extends Component {\n  private readonly _keyActions: { [key: string]: KeyAction }\n  private readonly _cumulativeDirection: Vector2\n  private _pressedKeys: Set<string> = new Set()\n\n  constructor(\n    private readonly _object: IObject,\n    private readonly _eventSystem: IEventSystem,\n    private readonly _input: IInputManager,\n    private readonly _useArrowKeys: boolean = true\n  ) {\n    super('MovementComponent')\n\n    this._cumulativeDirection = new Vector2()\n    this._keyActions = this.initializeKeyActions()\n\n    this._input.subscribeInputEvent('KeyDown', (key) => {\n      this._pressedKeys.add(key)\n      this.handleKeys()\n    })\n\n    this._input.subscribeInputEvent('KeyUp', (key) => {\n      this._pressedKeys.delete(key)\n      this.handleKeys()\n    })\n  }\n\n  private initializeKeyActions(): { [key: string]: KeyAction } {\n    const keyActions: { [key: string]: KeyAction } = {}\n\n    if (this._useArrowKeys) {\n      keyActions['ArrowLeft'] = () => this.updateDirection(-1, 0)\n      keyActions['ArrowRight'] = () => this.updateDirection(1, 0)\n      keyActions['ArrowUp'] = () => this.updateDirection(0, -1)\n      keyActions['ArrowDown'] = () => this.updateDirection(0, 1)\n    } else {\n      keyActions['a'] = () => this.updateDirection(-1, 0)\n      keyActions['d'] = () => this.updateDirection(1, 0)\n      keyActions['w'] = () => this.updateDirection(0, -1)\n      keyActions['s'] = () => this.updateDirection(0, 1)\n    }\n\n    return keyActions\n  }\n\n  private updateDirection(x: number, y: number): void {\n    this._cumulativeDirection.x += x\n    this._cumulativeDirection.y += y\n  }\n\n  private handleKeys(): void {\n    //console.log('Before handling keys:', this._cumulativeDirection)\n\n    this._cumulativeDirection.x = 0\n    this._cumulativeDirection.y = 0\n\n    this._pressedKeys.forEach((key) => {\n      const action = this._keyActions[key]\n      if (action) {\n        action()\n      }\n    })\n\n    const direction = this._cumulativeDirection.clone().normalize()\n\n    const scaledDirection = new Vector2(\n      direction.x * this._object.moveStep.x,\n      direction.y * this._object.moveStep.y\n    )\n\n    this._object.velocity.setValues(scaledDirection)\n    this._eventSystem.publish('playerMove', this._object.id)\n  }\n}\n```",
          "dateTime": "2024-01-02T19:23:11.814Z"
        },
        {
          "indexTitle": "MovementComponent Refactor",
          "question": "MovementComponent Refactor",
          "answer": "Not used for now (ObjectComponent has all data for now), but much simpler :)\n```typescript\nimport { IVector2 } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport default class MovementComponent extends Component {\n  public velocity: IVector2 = Vector2.zero\n  public useArrowKeys: boolean = true\n  public moveSpeed: number = 50\n\n  constructor() {\n    super('MovementComponent')\n  }\n}\n```",
          "dateTime": "2024-01-03T10:43:33.940Z"
        },
        {
          "indexTitle": "MovementSubSystem",
          "question": "MovementSubSystem",
          "answer": "```typescript\nimport { IEventSystem, IInputManager } from 'engine_api'\nimport Vector2 from '../../../math/vector/Vector2'\nimport MovementComponent from '../../component/MovementComponent'\nimport ObjectComponent from '../../component/ObjectComponent'\n\ntype KeyAction = () => void\n\nexport default class MovementSubSystem {\n  private readonly _keyAction: { [key: string]: KeyAction }\n  private readonly _cumulativeDirection: Vector2 = new Vector2()\n  private _pressedKey: Set<string> = new Set()\n\n  constructor(\n    private readonly _input: IInputManager,\n    private readonly _eventSystem: IEventSystem,\n    private readonly _id: string,\n    useArrowKeys: boolean = true\n  ) {\n    this._keyAction = useArrowKeys\n      ? this.initArrowKeyAction()\n      : this.initWSADKeyAction()\n  }\n\n  private initArrowKeyAction(): { [key: string]: KeyAction } {\n    const keyActions: { [key: string]: KeyAction } = {}\n\n    keyActions['ArrowLeft'] = () => this.updateDirection(-1, 0)\n    keyActions['ArrowRight'] = () => this.updateDirection(1, 0)\n    keyActions['ArrowUp'] = () => this.updateDirection(0, -1)\n    keyActions['ArrowDown'] = () => this.updateDirection(0, 1)\n\n    return keyActions\n  }\n\n  private initWSADKeyAction(): { [key: string]: KeyAction } {\n    const keyActions: { [key: string]: KeyAction } = {}\n\n    keyActions['a'] = () => this.updateDirection(-1, 0)\n    keyActions['d'] = () => this.updateDirection(1, 0)\n    keyActions['w'] = () => this.updateDirection(0, -1)\n    keyActions['s'] = () => this.updateDirection(0, 1)\n\n    return keyActions\n  }\n\n  private updateDirection(x: number, y: number): void {\n    this._cumulativeDirection.x += x\n    this._cumulativeDirection.y += y\n  }\n\n  subscribeInput(objectComponent: ObjectComponent) {\n    this._input.subscribeInputEvent('KeyDown', (key) => {\n      if (!this._keyAction.hasOwnProperty(key)) return\n      this._pressedKey.add(key)\n      this.handleKeys(objectComponent)\n    })\n\n    this._input.subscribeInputEvent('KeyUp', (key) => {\n      if (!this._keyAction.hasOwnProperty(key)) return\n      this._pressedKey.delete(key)\n      this.handleKeys(objectComponent)\n    })\n  }\n\n  private handleKeys(objectComponent: ObjectComponent): void {\n    this._cumulativeDirection.x = 0\n    this._cumulativeDirection.y = 0\n\n    this._pressedKey.forEach((key) => {\n      const action = this._keyAction[key]\n      if (action) {\n        action()\n      }\n    })\n\n    const direction = this._cumulativeDirection.clone().normalize()\n\n    const scaledDirection = new Vector2(\n      direction.x * objectComponent.moveStep.x,\n      direction.y * objectComponent.moveStep.x\n    )\n\n    objectComponent.velocity.setValues(scaledDirection)\n    this._eventSystem.publish('playerMove', this._id)\n  }\n}\n```",
          "dateTime": "2024-01-02T19:30:29.093Z"
        },
        {
          "indexTitle": "MovementSystem",
          "question": "MovementSystem",
          "answer": "```typescript\nimport {\n  IEntity,\n  IEntityManager,\n  IEventSystem,\n  IInputManager,\n} from 'engine_api'\nimport MovementComponent from '../../component/MovementComponent'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport MovementSubSystem from './MovementSubSystem'\nimport InitLogicSystemBase from './InitLogicSystemBase'\n\nexport default class MovementSystem extends InitLogicSystemBase {\n  private _subSystem: MovementSubSystem[] = []\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _input: IInputManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super(entityManager)\n  }\n\n  initLogic(entity: IEntity) {\n    const movementComponent = entity.getComponentByType(MovementComponent)\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n\n    const movementSubSystem = new MovementSubSystem(\n      this._input,\n      this._eventSystem,\n      objectComponent.id,\n      movementComponent.useArrowKeys\n    )\n    movementSubSystem.subscribeInput(objectComponent)\n    this._subSystem.push(movementSubSystem)\n  }\n}\n```",
          "dateTime": "2024-01-02T19:31:03.109Z"
        },
        {
          "indexTitle": "InitLogicSystemManager",
          "question": "InitLogicSystemManager",
          "answer": "This is added to engine and user can add systems that need to init on entities once.  \n```typescript\nimport MapManager from '../../entity_component/MapManager'\nimport IInitLogicSystem from './IInitLogicSystem'\nimport IInitLogicSystemManager from './IInitLogicSystemManager'\n\nexport default class InitLogicSystemManager\n  extends MapManager<IInitLogicSystem>\n  implements IInitLogicSystemManager\n{\n  init(): void {\n    for (const system of this.values()) {\n      system.init()\n    }\n  }\n}\n```",
          "dateTime": "2024-01-02T19:34:35.727Z"
        },
        {
          "indexTitle": "KinematicsComponent",
          "question": "KinematicsComponent",
          "answer": "Initially:  \n```typescript\nimport { IEntity, IEventSystem, IObject } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport ObjectComponent from './ObjectComponent'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport class KinematicsComponent extends Component {\n  private _objectComponent: IObject\n  private readonly frictionCoefficient: number = 0.85\n  private readonly stopThreshold: number = 3\n\n  constructor(\n    private readonly _entity: IEntity,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super('KinematicsComponent')\n    this._objectComponent = this._entity.getComponentByType(ObjectComponent)\n  }\n\n  update(dt: number) {\n    this._objectComponent.position.add(\n      Vector2.getNew(this._objectComponent.velocity).multiply(dt)\n    )\n\n    this._objectComponent.velocity.multiply(\n      Math.pow(this.frictionCoefficient, dt)\n    )\n\n    if (this._objectComponent.velocity.length() < this.stopThreshold) {\n      if (\n        this._objectComponent.velocity.x !== 0 ||\n        this._objectComponent.velocity.y !== 0\n      ) {\n        this._objectComponent.velocity.x = 0\n        this._objectComponent.velocity.y = 0\n        this._eventSystem.publish('ballStop')\n      }\n    }\n  }\n}\n```",
          "dateTime": "2024-01-02T20:15:08.921Z"
        },
        {
          "indexTitle": "KinematicsComponent Refactor",
          "question": "KinematicsComponent Refactor",
          "answer": "```typescript\nimport Component from '../entity_component/Component'\n\nexport class KinematicsComponent extends Component {\n  public frictionCoefficient: number = 0\n  public stopThreshold: number = 0\n\n  constructor() {\n    super('KinematicsComponent')\n  }\n}\n```",
          "dateTime": "2024-01-03T10:44:06.267Z"
        },
        {
          "indexTitle": "KinematicsSystem ",
          "question": "KinematicsSystem ",
          "answer": "```typescript\nimport { IEntity, IEntityManager, IEventSystem } from 'engine_api'\nimport LogicSystemBase from './LogicSystemBase'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport Vector2 from '../../../math/vector/Vector2'\nimport { KinematicsComponent } from '../../component/KinematicsComponent'\n\nexport default class KinematicsSystem extends LogicSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super(entityManager)\n  }\n\n  updateLogic(deltaTime: number, entity: IEntity): void {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const kinematicsComponent = entity.getComponentByType(KinematicsComponent)\n\n    objectComponent.position.add(\n      Vector2.getNew(objectComponent.velocity).multiply(deltaTime)\n    )\n\n    if (kinematicsComponent.frictionCoefficient > 0) {\n      objectComponent.velocity.multiply(\n        Math.pow(kinematicsComponent.frictionCoefficient, deltaTime)\n      )\n    }\n\n    if (\n      kinematicsComponent.stopThreshold > 0 &&\n      objectComponent.velocity.length() < kinematicsComponent.stopThreshold\n    ) {\n      if (\n        objectComponent.velocity.x !== 0 ||\n        objectComponent.velocity.y !== 0\n      ) {\n        objectComponent.velocity.x = 0\n        objectComponent.velocity.y = 0\n        this._eventSystem.publish('entityStopped', objectComponent.id)\n      }\n    }\n  }\n}\n```",
          "dateTime": "2024-01-02T21:36:16.110Z"
        }
      ]
    },
    {
      "title": "Task 32.",
      "chats": [
        {
          "indexTitle": "CollisionComponent Refactor",
          "question": "CollisionComponent Refactor  \n```typescript\nimport { ICollisionDetector, IEntity, IObject } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport CollisionHandlerComponent from './CollisionHandlerComponent'\nimport ObjectComponent from './ObjectComponent'\n\nexport default class CollisionComponent extends Component {\n  private _object1: IObject\n  private _object2!: IObject\n\n  set object2(object: IObject) {\n    this._object2 = object\n  }\n\n  constructor(\n    private readonly _collisionDetector: ICollisionDetector,\n    private readonly _entity: IEntity\n  ) {\n    super('CollisionComponent')\n    this._object1 = this._entity.getComponentByType(ObjectComponent)\n  }\n\n  setCollisionHandler() {\n    const collisionHandlerComponent = this._entity.getComponentByType(\n      CollisionHandlerComponent\n    )\n    this._collisionDetector.subscribeToCollisions(\n      this._object1,\n      this._object2,\n      collisionHandlerComponent.handleCollision.bind(collisionHandlerComponent)\n    )\n  }\n\n  update(dt: number) {\n    this._collisionDetector.checkCollision(this._object1, this._object2)\n  }\n\n  render(dt: number) {}\n}\n```\nI want to have component with only data like in unity components, here i think only thing that is needed is to get id of entity and also provide setter for id of object to collide with, all logic will be deleted from here as it will be moved to system.",
          "answer": "Certainly! To simplify your `CollisionComponent` and make it more data-oriented, you can remove unnecessary logic and keep it focused on storing data. Here's a simplified version:\n\n```typescript\nimport { ICollisionDetector, IEntity, IObject } from 'engine_api';\nimport Component from '../entity_component/Component';\n\nexport default class CollisionComponent extends Component {\n  private _objectIdToCollideWith: string | null = null;\n\n  constructor(private readonly _entity: IEntity) {\n    super('CollisionComponent');\n  }\n\n  // Getter for the entity ID\n  get entityId(): string {\n    return this._entity.id;\n  }\n\n  // Setter for the object ID to collide with\n  set objectIdToCollideWith(objectId: string | null) {\n    this._objectIdToCollideWith = objectId;\n  }\n\n  // Getter for the object ID to collide with\n  get objectIdToCollideWith(): string | null {\n    return this._objectIdToCollideWith;\n  }\n}\n```\n\nIn this simplified version:\n\n- Removed `_collisionDetector` dependency: The collision detection logic will be handled by a system outside of this component.\n- Removed `_object1` and `_object2`: We store only the object ID to collide with, eliminating the need for specific object references.\n- Removed `setCollisionHandler` and `update` methods: These were handling collision logic, which you've mentioned will be moved to a system.\n\nNow, this `CollisionComponent` primarily serves as a data container, providing the entity ID and the object ID to collide with. The actual collision handling and logic will be implemented in a separate system using the data provided by this component.",
          "dateTime": "2024-01-03T11:52:48.326Z"
        },
        {
          "indexTitle": "CollisionComponent Proposal",
          "question": "CollisionComponent Proposal  \n```typescript\nimport Component from '../entity_component/Component'\n\nexport default class CollisionComponent extends Component {\n  private _objectIdToCollideWith!: string\n\n  constructor() {\n    super('CollisionComponent')\n  }\n\n  set objectIdToCollideWith(objectId: string) {\n    this._objectIdToCollideWith = objectId\n  }\n\n  get objectIdToCollideWith(): string {\n    return this._objectIdToCollideWith\n  }\n}\n```\nIn fact i think this will suffice",
          "answer": "Absolutely, your simplified version looks great for a data-oriented `CollisionComponent`. It stores the object ID to collide with and provides a setter and getter for that value. This minimalist approach aligns with the principle of keeping components as simple data containers, leaving the logic to systems. If this meets your requirements, it's a clean and straightforward implementation.",
          "dateTime": "2024-01-03T11:53:02.475Z"
        },
        {
          "indexTitle": "CollisionSystem Proposal",
          "question": "CollisionSystem Proposal",
          "answer": "```typescript\nimport {\n  ICollisionDetector,\n  ICollisionHandler,\n  IEntity,\n  IEntityManager,\n} from 'engine_api'\nimport LogicSystemBase from './logic/LogicSystemBase'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport CollisionComponent from '../../component/CollisionComponent'\n\nexport default class CollisionSystem extends LogicSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _collisionDetector: ICollisionDetector,\n    private readonly _collisionHandler: ICollisionHandler\n  ) {\n    super(entityManager)\n  }\n\n  initilize(entity: IEntity) {\n    const [objectComponent, objectComponent2] = this.getData(entity)\n    this._collisionDetector.subscribeToCollisions(\n      objectComponent,\n      objectComponent2,\n      this._collisionHandler.handleCollision.bind(this._collisionHandler)\n    )\n  }\n\n  private getData(entity: IEntity): [ObjectComponent, ObjectComponent] {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const collisionComponent = entity.getComponentByType(CollisionComponent)\n    const objectComponent2 = this.entityManager\n      .getStrict(collisionComponent.objectIdToCollideWith)\n      .getComponentByType(ObjectComponent)\n    return [objectComponent, objectComponent2]\n  }\n\n  updateLogic(deltaTime: number, entity: IEntity): void {\n    const [objectComponent, objectComponent2] = this.getData(entity)\n    this._collisionDetector.checkCollision(objectComponent, objectComponent2)\n  }\n}\n```",
          "dateTime": "2024-01-03T13:42:04.504Z"
        },
        {
          "indexTitle": "Use in game",
          "question": "Use in game  \nClumsy but at least its a system and not logic in component.  \nLogic in component should be defined in game, not engine, mostly.",
          "answer": "```typescript\nconst playerBallCollisionSystem = new CollisionSystem(\n      engine.entityManager,\n      engine.collisionManager.getCollisionDetector(),\n      new PlayerBallCollisionHandler(engine.eventSystem)\n    )\n    playerBallCollisionSystem.registerEntityByName('player1')\n    playerBallCollisionSystem.registerEntityByName('player2')\n    const player1Collider = player1.getComponentByType(CollisionComponent)\n    player1Collider.objectIdToCollideWith = ballObj.id\n    playerBallCollisionSystem.initilize(player1)\n    const player2Collider = player2.getComponentByType(CollisionComponent)\n    player2Collider.objectIdToCollideWith = ballObj.id\n    playerBallCollisionSystem.initilize(player2)\n    engine.logicSystemManager.add(\n      'playerBallCollision',\n      playerBallCollisionSystem\n    )\n\n    const ballGateCollisionSystem = new CollisionSystem(\n      engine.entityManager,\n      engine.collisionManager.getCollisionDetector(),\n      new BallGateCollisionHandler(\n        entityManager,\n        engine.entityDataManager,\n        engine.eventSystem\n      )\n    )\n    ballGateCollisionSystem.registerEntityByName('leftGate')\n    ballGateCollisionSystem.registerEntityByName('rightGate')\n    const leftGateCollider = leftGate.getComponentByType(CollisionComponent)\n    leftGateCollider.objectIdToCollideWith = ballObj.id\n    ballGateCollisionSystem.initilize(leftGate)\n    const rightGateCollider = rightGate.getComponentByType(CollisionComponent)\n    rightGateCollider.objectIdToCollideWith = ballObj.id\n    ballGateCollisionSystem.initilize(rightGate)\n    engine.logicSystemManager.add('ballGateCollision', ballGateCollisionSystem)\n```",
          "dateTime": "2024-01-03T13:46:23.943Z"
        },
        {
          "indexTitle": "InsideWallsCollisionSystem Refactor",
          "question": "InsideWallsCollisionSystem Refactor",
          "answer": "Two classes made from InsideWallsCollisionSystem :\n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport LogicSystemBase from './logic/LogicSystemBase'\nimport { ICollisionSubSystem } from './ICollisionSubSystem'\n\nexport default class SimpleCollisionSystem extends LogicSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _collisionSubSystem: ICollisionSubSystem\n  ) {\n    super(entityManager)\n  }\n\n  updateLogic(deltaTime: number, entity: IEntity) {\n    this._collisionSubSystem.updateLogic(deltaTime, entity)\n  }\n}\n```\n```typescript\nimport { IEntity } from 'engine_api'\n\nexport interface ICollisionSubSystem {\n  updateLogic(deltaTime: number, entity: IEntity): void\n}\n```\n```typescript\nimport { IEntity } from 'engine_api'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport WallComponent from '../component/WallComponent'\nimport CollisionCircleComponent from '../component/CollisionCircleComponent'\nimport CircleComponent from '../component/CircleComponent'\nimport { ICollisionSubSystem } from './ICollisionSubSystem'\n\nenum Axis {\n  X = 'x',\n  Y = 'y',\n}\n\nexport default class InsideBoxCollisionSubSystem\n  implements ICollisionSubSystem\n{\n  updateLogic(deltaTime: number, entity: IEntity) {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const circleComponent = entity.getComponentByType(CollisionCircleComponent)\n    const wallComponent = entity.getComponentByType(WallComponent)\n    ;[Axis.X, Axis.Y].forEach((axis: any) => {\n      this.checkAndHandleCollision(\n        objectComponent,\n        circleComponent,\n        wallComponent,\n        axis\n      )\n    })\n  }\n\n  private checkAndHandleCollision(\n    object: ObjectComponent,\n    circle: CircleComponent,\n    wall: WallComponent,\n    axis: Axis\n  ) {\n    const position = object.position[axis]\n    const radius = circle.radius\n    const wallPosition = wall.size[axis]\n\n    if (this.isCollisionDetected(position, radius, wallPosition)) {\n      this.resolveCollision(object, radius, wallPosition, axis)\n    }\n  }\n\n  private isCollisionDetected(\n    position: number,\n    radius: number,\n    maxlimit: number,\n    minLimit: number = 0\n  ): boolean {\n    return position - radius <= minLimit || position + radius >= maxlimit\n  }\n\n  private resolveCollision(\n    object: ObjectComponent,\n    radius: number,\n    maxLimit: number,\n    axis: Axis\n  ) {\n    object.velocity[axis] *= -1\n    object.position[axis] = this.adjustPosition(\n      object.position[axis],\n      radius,\n      maxLimit\n    )\n  }\n\n  private adjustPosition(\n    position: number,\n    radius: number,\n    limit: number\n  ): number {\n    return Math.max(radius, Math.min(limit - radius, position))\n  }\n}\n```",
          "dateTime": "2024-01-03T16:24:35.971Z"
        },
        {
          "indexTitle": "LimitMoveComponent Refactor",
          "question": "LimitMoveComponent Refactor",
          "answer": "From :\n```typescript\nimport Component from '../entity_component/Component'\nimport { IObject, IVector2 } from 'engine_api'\n\nexport default class LimitMoveComponent extends Component {\n  constructor(\n    private readonly _limitSize: IVector2,\n    private readonly _object: IObject\n  ) {\n    super('LimitMoveComponent')\n  }\n\n  update(dt: number) {\n    const halfWidth = this._object.size.x / 2\n    const halfHeight = this._object.size.y / 2\n\n    const newX = Math.max(\n      halfWidth,\n      Math.min(this._limitSize.x - halfWidth, this._object.position.x)\n    )\n    const newY = Math.max(\n      halfHeight,\n      Math.min(this._limitSize.y - halfHeight, this._object.position.y)\n    )\n\n    this._object.position.x = newX\n    this._object.position.y = newY\n  }\n}\n```\nTo:\n```typescript\nimport Vector2 from '../../math/vector/Vector2'\nimport Component from '../entity_component/Component'\nimport { IVector2 } from 'engine_api'\n\nexport default class LimitMoveComponent extends Component {\n  public limitSize: IVector2 = new Vector2()\n\n  constructor() {\n    super('LimitMoveComponent')\n  }\n}\n```\nAdd:\n```typescript\nimport { IEntity } from 'engine_api'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport { ICollisionSubSystem } from './ICollisionSubSystem'\nimport LimitMoveComponent from '../../component/LimitMoveComponent'\n\nexport default class LimitMoveSubSystem implements ICollisionSubSystem {\n  updateLogic(deltaTime: number, entity: IEntity) {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const limitMoveComponent = entity.getComponentByType(LimitMoveComponent)\n\n    const halfWidth = objectComponent.size.x / 2\n    const halfHeight = objectComponent.size.y / 2\n\n    const newX = Math.max(\n      halfWidth,\n      Math.min(\n        limitMoveComponent.limitSize.x - halfWidth,\n        objectComponent.position.x\n      )\n    )\n    const newY = Math.max(\n      halfHeight,\n      Math.min(\n        limitMoveComponent.limitSize.y - halfHeight,\n        objectComponent.position.y\n      )\n    )\n\n    objectComponent.position.x = newX\n    objectComponent.position.y = newY\n  }\n}\n```\nUse it:\n```typescript\nconst limitSystem = new SimpleCollisionSystem(\n      engine.entityManager,\n      new LimitMoveSubSystem()\n    )\n    limitSystem.registerEntityByName('player1')\n    limitSystem.registerEntityByName('player2')\n    engine.logicSystemManager.add('limitMove', limitSystem)\n```",
          "dateTime": "2024-01-03T16:42:41.976Z"
        },
        {
          "indexTitle": "SpriteComponent and RenderComponent Refactor",
          "question": "SpriteComponent and RenderComponent Refactor",
          "answer": "From:\n```typescript\nimport { IObject, IRendererV2 } from 'engine_api'\nimport Component from '../entity_component/Component'\n\nexport default class RenderComponent extends Component {\n  constructor(\n    private readonly _object: IObject,\n    private readonly _renderer: IRendererV2\n  ) {\n    super('RenderComponent')\n  }\n\n  update(dt: number) {}\n\n  render(dt: number) {\n    this._renderer.drawObject(this._object)\n  }\n}\n```\n```typescript\nimport { IAnimationConfig, IObject, IRendererV2 } from 'engine_api'\nimport { SpriteAnimator } from '../sprite/SpriteAnimator'\nimport Component from '../entity_component/Component'\n\nexport default class SpriteComponent extends Component {\n  private sprite: SpriteAnimator\n\n  constructor(\n    private readonly _renderer: IRendererV2,\n    private readonly _object: IObject,\n    animations: IAnimationConfig[]\n  ) {\n    super('SpriteComponent')\n    this.sprite = new SpriteAnimator(animations)\n  }\n\n  update(dt: number) {\n    this.sprite.update(dt)\n  }\n\n  render(dt: number) {\n    this.sprite.draw(\n      this._renderer.ctx,\n      this._object.position.x + this._object.spriteOffset.x,\n      this._object.position.y + this._object.spriteOffset.y,\n      this._object.isFlipped\n    )\n  }\n\n  switchAnimation(animationIndex: number) {\n    this.sprite.switchAnimation(animationIndex)\n  }\n}\n```\nTo:\n```typescript\nimport { IAnimationConfig } from 'engine_api'\nimport Component from '../entity_component/Component'\n\nexport default class RenderComponent extends Component {\n  public renderObject: boolean = true\n  public spriteAnimation: IAnimationConfig[] = [] \n\n  constructor() {\n    super('RenderComponent')\n  }\n}\n```\n```typescript\nimport IRegisterEntityByName from '../IRegisterEntityByName'\n\nexport default interface IRenderSystem extends IRegisterEntityByName {\n  render(deltaTime: number): void\n}\n```\n```typescript\nimport { IManager } from 'engine_api'\nimport IRenderSystem from './IRenderSystem'\n\nexport default interface IRenderSystemManager extends IManager<IRenderSystem> {\n  render(deltaTime: number): void\n}\n```\n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport IRenderSystem from './IRenderSystem'\n\nexport default abstract class RenderSystemBase implements IRenderSystem {\n  protected entityList: IEntity[] = []\n\n  constructor(protected readonly entityManager: IEntityManager) {}\n\n  render(deltaTime: number): void {\n    this.iterateEntities((entity) => this.renderLogic(deltaTime, entity))\n  }\n\n  private iterateEntities(callback: (entity: IEntity) => void): void {\n    for (const entity of this.entityList) {\n      callback(entity)\n    }\n  }\n\n  abstract renderLogic(deltaTime: number, entity: IEntity): void\n\n  registerEntityByName(name: string): void {\n    this.entityList.push(this.entityManager.getStrict(name))\n  }\n}\n```\n```typescript\nimport MapManager from '../../../entity_component/MapManager'\nimport IRenderSystem from './IRenderSystem'\nimport IRenderSystemManager from './IRenderSystemManager'\n\nexport default class RenderSystemManager\n  extends MapManager<IRenderSystem>\n  implements IRenderSystemManager\n{\n  render(dt: number): void {\n    for (const system of this.values()) {\n      system.render(dt)\n    }\n  }\n}\n```\n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport RenderSystemBase from './render/RenderSystemBase'\nimport IRenderSubSystem from './IRenderSubSystem'\n\nexport default class RenderSystem extends RenderSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _renderSubSystem: IRenderSubSystem\n  ) {\n    super(entityManager)\n  }\n\n  renderLogic(deltaTime: number, entity: IEntity) {\n    this._renderSubSystem.renderLogic(deltaTime, entity)\n  }\n}\n```\n```typescript\nimport { IEntity, IEventSystem, IRendererV2 } from 'engine_api'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport IRenderSubSystem from './IRenderSubSystem'\nimport RenderComponent from '../../component/RenderComponent'\nimport { SpriteAnimator } from '../../sprite/SpriteAnimator'\n\nexport default class RenderSubSystem implements IRenderSubSystem {\n  constructor(\n    private readonly _renderer: IRendererV2,\n    private readonly _spriteAnimator: SpriteAnimator,\n    private readonly _eventSystem: IEventSystem,\n    entity: IEntity\n  ) {\n    this._eventSystem.subscribe(\n      'animation',\n      (data: { id: string; animId: number }) => {\n        if (data.id === entity.getComponentByType(ObjectComponent).id)\n          this._spriteAnimator.switchAnimation(data.animId)\n      }\n    )\n  }\n\n  renderLogic(deltaTime: number, entity: IEntity) {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const renderComponent = entity.getComponentByType(RenderComponent)\n\n    if (renderComponent.spriteAnimation.length > 0) {\n      this._spriteAnimator.update(deltaTime)\n      this._spriteAnimator.draw(\n        this._renderer.ctx,\n        objectComponent.position.x + objectComponent.spriteOffset.x,\n        objectComponent.position.y + objectComponent.spriteOffset.y,\n        objectComponent.isFlipped\n      )\n    }\n    if (renderComponent.renderObject) this._renderer.drawObject(objectComponent)\n  }\n}\n```\n```typescript\n const player1RenderSystem = new RenderSystem(\n      entityManager,\n      new RenderSubSystem(\n        engine.renderer,\n        new SpriteAnimator(\n          engine.entityDataManager.getStrict('player1').animations\n        ),\n        engine.eventSystem,\n        player1\n      )\n    )\n    player1RenderSystem.registerEntityByName('player1')\n    const player2RenderSystem = new RenderSystem(\n      entityManager,\n      new RenderSubSystem(\n        engine.renderer,\n        new SpriteAnimator(\n          engine.entityDataManager.getStrict('player2').animations\n        ),\n        engine.eventSystem,\n        player2\n      )\n    )\n    player2RenderSystem.registerEntityByName('player2')\n    const ballRenderSystem = new RenderSystem(\n      entityManager,\n      new RenderSubSystem(\n        engine.renderer,\n        new SpriteAnimator(\n          engine.entityDataManager.getStrict('ball').animations\n        ),\n        engine.eventSystem,\n        ball\n      )\n    )\n    ballRenderSystem.registerEntityByName('ball')\n    const leftGateRenderSystem = new RenderSystem(\n      entityManager,\n      new RenderSubSystem(\n        engine.renderer,\n        new SpriteAnimator(\n          engine.entityDataManager.getStrict('leftGate').animations\n        ),\n        engine.eventSystem,\n        leftGate\n      )\n    )\n    leftGateRenderSystem.registerEntityByName('leftGate')\n    const rightGateRenderSystem = new RenderSystem(\n      entityManager,\n      new RenderSubSystem(\n        engine.renderer,\n        new SpriteAnimator(\n          engine.entityDataManager.getStrict('rightGate').animations\n        ),\n        engine.eventSystem,\n        rightGate\n      )\n    )\n    rightGateRenderSystem.registerEntityByName('rightGate')\n    const fieldRenderSystem = new RenderSystem(\n      entityManager,\n      new RenderSubSystem(\n        engine.renderer,\n        new SpriteAnimator(\n          engine.entityDataManager.getStrict('field').animations\n        ),\n        engine.eventSystem,\n        field\n      )\n    )\n    fieldRenderSystem.registerEntityByName('field')\n    engine.renderSystemManager.add('field', fieldRenderSystem)\n    engine.renderSystemManager.add('ball', ballRenderSystem)\n    engine.renderSystemManager.add('leftGate', leftGateRenderSystem)\n    engine.renderSystemManager.add('rightGate', rightGateRenderSystem)\n    engine.renderSystemManager.add('player1', player1RenderSystem)\n    engine.renderSystemManager.add('player2', player2RenderSystem)\n```\nUsage is very cumbersome, this needs to change but time was low",
          "dateTime": "2024-01-03T19:50:48.783Z"
        }
      ]
    },
    {
      "title": "Task 33.",
      "chats": [
        {
          "indexTitle": "GameStateComponent Refactor",
          "question": "GameStateComponent Refactor",
          "answer": "```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n```typescript\n```\n\n",
          "dateTime": "2024-01-04T12:28:04.865Z"
        }
      ]
    }
  ]
}