{
  "sections": [
    {
      "title": "Entity",
      "chats": [
        {
          "indexTitle": "Entity Base",
          "question": "Entity Base",
          "answer": "* Entity part of Entity Component System in game engine  \n* It has string id and stores components of game object that i call Entity  \n```plaintext\n|-- engine_api/\n|   |-- src/\n|       |-- ecs\n|           |-- entity\n|               |-- IEntity.ts\n|               |-- IEntityWithComponents.ts\n|               |-- IRenderable.ts\n|               |-- IUpdatable.ts\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs\n|           |-- entity\n|               |-- Entity.ts\n```\n```typescript\nimport IEntityWithComponents from './IEntityWithComponents'\n\nexport default interface IEntity extends IEntityWithComponents {\n  id: string\n}\n```\n```typescript\nimport { ClassType } from '../../tech/entity_component/ClassType'\nimport IComponent from '../../tech/entity_component/IComponent'\nimport IRenderable from './IRenderable'\nimport IUpdatable from './IUpdatable'\n\nexport default interface IEntityWithComponents extends IUpdatable, IRenderable {\n  addComponent(component: IComponent): void\n  addComponents(components: IComponent[]): void\n  getComponentStrict<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T\n  getComponent<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T | undefined\n}\n```\n```typescript\nexport default interface IRenderable {\n  render(deltaTime: number): void\n}\n```\n```typescript\nexport default interface IUpdatable {\n  update(deltaTime: number): void\n}\n```\n```typescript\nimport {\n  ClassType,\n  IComponent,\n  IEntity,\n  IEntityWithComponents,\n} from 'engine_api'\n\nexport default class Entity implements IEntityWithComponents, IEntity {\n  private _components = new Map<ClassType<IComponent>, IComponent[]>()\n  private _id!: string\n\n  get id(): string {\n    return this._id\n  }\n\n  set id(id: string) {\n    this._id = id\n  }\n\n  addComponent(component: IComponent): void {\n    this.addComponentToEntity(component)\n  }\n\n  addComponents(components: IComponent[]): void {\n    for (const component of components) {\n      this.addComponentToEntity(component)\n    }\n  }\n\n  private addComponentToEntity(component: IComponent) {\n    const componentType = component.constructor as ClassType<IComponent>\n\n    if (!this._components.has(componentType)) {\n      this._components.set(componentType, [component])\n    } else {\n      this._components.get(componentType)!.push(component)\n    }\n  }\n\n  getComponent<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T | undefined {\n    const components = this._components.get(componentType)\n\n    if (components) {\n      if (id) {\n        return components.find((item) => item.id === id) as T | undefined\n      } else {\n        return components[0] as T | undefined\n      }\n    }\n\n    return undefined\n  }\n\n  getComponentStrict<T extends IComponent>(\n    componentType: ClassType<T>,\n    id?: string\n  ): T {\n    const components = this._components.get(componentType)\n    const errorMessage = (id?: string) =>\n      id\n        ? `Component of type ${componentType.name} and id ${id} not found.`\n        : `No components of type ${componentType.name} found.`\n    if (components) {\n      if (id) {\n        const component = components.find((item) => item.id === id) as\n          | T\n          | undefined\n\n        if (component) {\n          return component\n        } else {\n          throw new Error(errorMessage(id))\n        }\n      } else {\n        const firstComponent = components[0] as T | undefined\n\n        if (firstComponent) {\n          return firstComponent\n        } else {\n          throw new Error(errorMessage())\n        }\n      }\n    } else {\n      throw new Error(errorMessage())\n    }\n  }\n\n  update(deltaTime: number): void {\n    for (const componentArrays of this._components.values()) {\n      for (const component of componentArrays) {\n        component.update(deltaTime)\n      }\n    }\n  }\n\n  render(deltaTime: number): void {\n    for (const componentArrays of this._components.values()) {\n      for (const component of componentArrays) {\n        component.render(deltaTime)\n      }\n    }\n  }\n}\n```",
          "dateTime": "2024-02-12T12:30:03.602Z"
        }
      ]
    },
    {
      "title": "Component",
      "chats": [
        {
          "indexTitle": "Component Base",
          "question": "Component Base",
          "answer": "* Component part of Entity Component System in game engine  \n* This type defines data model and content of Entity  \n```plaintext\n|-- engine_api/\n|   |-- src/\n|       |-- ecs/\n|           |-- component/\n|               |-- ClassType.ts\n|               |-- IComponent.ts\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- component/\n|               |-- Component.ts\n```\n```typescript\nexport type ClassType<T> = abstract new (...args: any[]) => T\n```\n```typescript\nexport default interface IComponent {\n  update(deltaTime: number): void\n  render(deltaTime: number): void\n  get id(): string\n  set id(id: string)\n}\n```\n```typescript\nimport { IComponent } from 'engine_api'\n\nexport default abstract class Component implements IComponent {\n  private _id!: string\n\n  get id(): string {\n    return this._id\n  }\n\n  set id(id: string) {\n    this._id = id\n  }\n\n  update(_deltaTime: number) {}\n\n  render(_deltaTime: number) {}\n}\n```",
          "dateTime": "2024-02-12T12:31:00.828Z"
        },
        {
          "indexTitle": "Components",
          "question": "Components",
          "answer": "```typescript\nimport { IBoxCollider, IVector2 } from 'engine_api'\nimport Vector2 from '../../math/vector/Vector2'\nimport Collider from './base/Collider'\n\nexport default class BoxCollider extends Collider implements IBoxCollider {\n  private _size: IVector2 = new Vector2()\n  private _halfSize: IVector2 = new Vector2()\n\n  public get size(): IVector2 {\n    return this._size\n  }\n\n  public set size(size: IVector2) {\n    this._size = size\n    this._halfSize.x = this._size.x / 2\n    this._halfSize.y = this._size.y / 2\n  }\n\n  public get halfSize(): IVector2 {\n    return this._halfSize\n  }\n}\n```\n```typescript\nimport { ICircleCollider } from 'engine_api'\nimport Collider from './base/Collider'\n\nexport default class CircleCollider\n  extends Collider\n  implements ICircleCollider\n{\n  private _radius: number = 100\n\n  public get radius(): number {\n    return this._radius\n  }\n\n  public set radius(radius: number) {\n    this._radius = radius\n  }\n}\n```\n```typescript\nimport { InputDto } from 'engine_api'\nimport Component from './base/Component'\n\nexport default class ClientMovement extends Component {\n  private readonly _inputDto: InputDto = new InputDto()\n\n  get inputDto(): InputDto {\n    return this._inputDto\n  }\n}\n```\n```typescript\nimport { ICollisionObject } from 'engine_api'\nimport Component from './base/Component'\n\nexport default class CollisionObject\n  extends Component\n  implements ICollisionObject\n{\n  private _objectIdToCollideWith!: string\n\n  set objectIdToCollideWith(objectId: string) {\n    this._objectIdToCollideWith = objectId\n  }\n\n  get objectIdToCollideWith(): string {\n    return this._objectIdToCollideWith\n  }\n}\n```\n```typescript\nimport { ICollisionInfo, IScoreInfo, IVector2 } from 'engine_api'\nimport Component from './base/Component'\nimport { IGameState } from 'engine_api'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport default class GameState extends Component implements IGameState {\n  private _lastCollisionInfo: ICollisionInfo = {} as ICollisionInfo\n  private _score: IScoreInfo = { redScore: 0, blueScore: 0 } as IScoreInfo\n  private _position: IVector2 = new Vector2()\n\n  public get lastCollisionInfo(): ICollisionInfo {\n    return this._lastCollisionInfo\n  }\n\n  public set lastCollisionInfo(lastCollisionInfo: ICollisionInfo) {\n    this._lastCollisionInfo = lastCollisionInfo\n  }\n\n  public get score(): IScoreInfo {\n    return this._score\n  }\n\n  public set score(score: IScoreInfo) {\n    this._score = score\n  }\n\n  public get position(): IVector2 {\n    return this._position\n  }\n\n  public set position(position: IVector2) {\n    this._position = position\n  }\n}\n```\n```typescript\nimport BoxCollider from './BoxCollider'\n\nexport default class InsideBoxCollider extends BoxCollider {}\n```\n```typescript\nimport Vector2 from '../../math/vector/Vector2'\nimport { ILimitMove, IVector2 } from 'engine_api'\nimport Collider from './base/Collider'\n\nexport default class LimitMove extends Collider implements ILimitMove {\n  private _limitSize: IVector2 = new Vector2()\n\n  public get limitSize(): IVector2 {\n    return this._limitSize\n  }\n\n  public set limitSize(limitSize: IVector2) {\n    this._limitSize = limitSize\n  }\n}\n```\n```typescript\nimport { IVector2 } from 'engine_api'\nimport Vector2 from '../../math/vector/Vector2'\nimport Component from './core/Component'\n\nexport default class Direction extends Component {\n  private _direction: IVector2 = new Vector2(1, 0)\n\n  public get direction(): IVector2 {\n    return this._direction\n  }\n\n  public set direction(v: IVector2) {\n    this._direction.x = v.x\n    this._direction.y = v.y\n    this._direction.normalize()\n  }\n}\n```",
          "dateTime": "2024-02-12T14:54:53.448Z"
        }
      ]
    },
    {
      "title": "System",
      "chats": [
        {
          "indexTitle": "System Base",
          "question": "System Base",
          "answer": "```plaintext\n|-- engine_api/\n|   |-- src/\n|       |-- ecs/\n|           |-- system/\n|               |-- ISystem.ts\n|        |-- IStartable .ts\n|        |-- IUpdateable .ts\n```\n```typescript\nexport default interface IStartable {\n  start(): void\n}\n```\n```typescript\nexport default interface IUpdateable {\n  update(deltaTime: number): void\n}\n```\n```typescript\nimport IStartable from '../IStartable'\nimport IUpdateable from '../IUpdateable'\n\nexport default interface ISystem extends IStartable, IUpdateable {}\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- system/\n|               |-- base/\n|                   |-- IRegisterEntityById.ts\n|                   |-- ISystemManager.ts\n|                   |-- SystemBase.ts\n|                   |-- SystemManager.ts\n```\n```typescript\nexport default interface IRegisterEntityById {\n  registerEntityById(entityId: string): void\n}\n```\n```typescript\nimport { IManager, ISystem, IUpdateable } from 'engine_api'\n\nexport default interface ISystemManager\n  extends IUpdateable,\n    IManager<ISystem> {}\n```\n```typescript\nimport { IEntity, IStartable, IManager, IUpdateable } from 'engine_api'\nimport IRegisterEntityById from './IRegisterEntityById'\n\nexport default abstract class SystemBase\n  implements IStartable, IUpdateable, IRegisterEntityById\n{\n  protected _entity!: IEntity\n\n  constructor(protected readonly _entityManager: IManager<IEntity>) {}\n\n  registerEntityById(entityId: string): void {\n    this._entity = this._entityManager.getStrict(entityId)\n  }\n\n  start() {}\n\n  update(_deltaTime: number) {}\n}\n```\n```typescript\nimport { ISystem } from 'engine_api'\nimport ISystemManager from './ISystemManager'\nimport MapManager from '../../entity/manager/MapManager'\n\nexport default class SystemManager\n  extends MapManager<ISystem>\n  implements ISystemManager\n{\n  update(deltaTime: number): void {\n    for (const system of this.values()) {\n      system.update(deltaTime)\n    }\n  }\n}\n```",
          "dateTime": "2024-02-12T12:31:19.840Z"
        },
        {
          "indexTitle": "PlayerKick",
          "question": "PlayerKick",
          "answer": "```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- system/\n|               |-- PlayerKick.ts\n```\n```typescript\nimport { IEntity, IEntityManager, IEventSystem } from 'engine_api'\nimport { KeyboardEvent, KeyboardKeys } from './keyboard/keyboardTypes'\nimport SystemBase from './base/SystemBase'\nimport IKeyboardEventData from './keyboard/IKeyboardEventData'\nimport RigidBody from '../component/RigidBody'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport default class PlayerKick extends SystemBase {\n  protected _ball!: IEntity\n  private ball_rb!: RigidBody\n  private player_rb!: RigidBody\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super(entityManager)\n    this._eventSystem.subscribe(KeyboardEvent, this.kick.bind(this))\n  }\n\n  registerBallById(entityId: string): void {\n    this._ball = this._entityManager.getStrict(entityId)\n  }\n\n  start(): void {\n    this.ball_rb = this._ball.getComponentStrict(RigidBody)\n    this.player_rb = this._entity.getComponentStrict(RigidBody)\n  }\n\n  private kick(data: IKeyboardEventData) {\n    if (data.key !== KeyboardKeys.z) return\n    console.log('handleZKey')\n    const vn = Vector2.getNew(this.player_rb.velocity).normalize()\n    this.ball_rb.velocity = vn.multiply(250)\n    console.log(this.ball_rb.velocity)\n  }\n}\n```",
          "dateTime": "2024-02-08T22:59:08.234Z"
        },
        {
          "indexTitle": "KeyboardMappingSystem",
          "question": "KeyboardMappingSystem",
          "answer": "* Mapping keyboard keys to events  \n```plaintext\n|-- engine_api/\n|   |-- src/\n```\n```plaintext\n|-- engine/\n|   |-- src/\n|       |--ecs\n|           |--system\n|               |--keyboard\n|                   |--KeyboardMappingSubSystem.ts\n|                   |--KeyboardMappingSystem.ts\n|                   |--keyboardTypes.ts\n```\n```typescript\nexport type KeyAction = () => void\n\nexport type KeyActionMap = { [key: string]: KeyAction }\n\nexport type KeyEvent = 'KeyDown' | 'KeyUp'\n\nexport const KeyEvents: { [key in KeyEvent]: key } = {\n  KeyDown: 'KeyDown',\n  KeyUp: 'KeyUp',\n}\n\nexport type KeyActionWithParam<T> = (data: T) => void\n\nexport type KeyActionWithParamMap<T> = { [key: string]: KeyActionWithParam<T> }\n\nexport const KeyboardEvent = 'KeyboardEvent'\n\nexport type KeyboardKey = 'q' | 'e' | 'z' | 'x'\n\nexport const KeyboardKeys: { [key in KeyboardKey]: key } = {\n  q: 'q',\n  e: 'e',\n  z: 'z',\n  x: 'x',\n}\n```\n```typescript\nimport { KeyboardKey } from './keyboardTypes'\n\nexport default interface IKeyboardEventData {\n  entityId: string\n  key: KeyboardKey\n}\n```\n```typescript\nimport { IEntity } from 'engine_api'\n\nexport default interface IKeyboardMappingSubSystem {\n  subscribeInput(entity: IEntity): void\n  unsubscribeInput(): void\n}\n```\n```typescript\nimport { IInputManager, IEventSystem, IEntity } from 'engine_api'\nimport {\n  KeyActionWithParamMap,\n  KeyEvents,\n  KeyboardEvent,\n  KeyboardKeys,\n} from './keyboardTypes'\nimport IKeyboardMappingSubSystem from './IKeyboardMappingSubSystem'\nimport IKeyboardEventData from './IKeyboardEventData'\n\nexport default class KeyboardMappingSubSystem\n  implements IKeyboardMappingSubSystem\n{\n  private _keyActions: KeyActionWithParamMap<string>\n  private _keyDownCallback!: (key: string) => void\n\n  constructor(\n    private readonly _inputManager: IInputManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    this._keyActions = this.initKeyAction()\n  }\n\n  private initKeyAction() {\n    return {\n      q: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.q,\n        } as IKeyboardEventData),\n      e: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.e,\n        } as IKeyboardEventData),\n      z: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.z,\n        } as IKeyboardEventData),\n      x: (id) =>\n        this._eventSystem.publish(KeyboardEvent, {\n          entityId: id,\n          key: KeyboardKeys.x,\n        } as IKeyboardEventData),\n    } as KeyActionWithParamMap<string>\n  }\n\n  subscribeInput(entity: IEntity): void {\n    this._keyDownCallback = (inputKey: string) => {\n      const key = inputKey.toLowerCase()\n      if (this.isKeyMapped(key)) return\n      this._keyActions[key](entity.id)\n    }\n\n    this._inputManager.subscribeInputEvent(\n      KeyEvents.KeyDown,\n      this._keyDownCallback\n    )\n  }\n\n  unsubscribeInput() {\n    this._inputManager.unsubscribeInputEvent(\n      KeyEvents.KeyDown,\n      this._keyDownCallback\n    )\n  }\n\n  private isKeyMapped(key: string) {\n    return !this._keyActions.hasOwnProperty(key)\n  }\n}\n```\n```typescript\nimport { IFactory, IInputManager, IEventSystem } from 'engine_api'\nimport IKeyboardMappingSubSystem from './IKeyboardMappingSubSystem'\nimport KeyboardMappingSubSystem from './KeyboardMappingSubSystem'\n\nexport default class KeyboardMappingSubSystemFactory\n  implements IFactory<IKeyboardMappingSubSystem>\n{\n  constructor(\n    private readonly _input: IInputManager,\n    private readonly _eventSystem: IEventSystem\n  ) {}\n\n  create(): IKeyboardMappingSubSystem {\n    return new KeyboardMappingSubSystem(this._input, this._eventSystem)\n  }\n}\n```\n```typescript\nimport { IEntityManager, IEntity, IManager, IFactory } from 'engine_api'\nimport InitLogicSystemBase from '../base/init_logic/InitLogicSystemBase'\nimport IKeyboardMappingSubSystem from './IKeyboardMappingSubSystem'\nimport MapManager from '../../entity/manager/MapManager'\n\nexport default class KeyboardMappingSystem extends InitLogicSystemBase {\n  private _subSystemManager: IManager<IKeyboardMappingSubSystem> =\n    new MapManager<IKeyboardMappingSubSystem>()\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _subSystemFactory: IFactory<IKeyboardMappingSubSystem>\n  ) {\n    super(entityManager)\n  }\n\n  initLogic(entity: IEntity): void {\n    const subSystem = this._subSystemFactory.create()\n    subSystem.subscribeInput(entity)\n    this._subSystemManager.add(entity.id, subSystem)\n  }\n\n  unsubscribe(entity: IEntity) {\n    const subSystem = this._subSystemManager.getStrict(entity.id)\n    subSystem.unsubscribeInput()\n  }\n}\n```\n* GameSystemBuilder, use it in SinglePlayerBuilder->withSystems()\n```typescript\nwithKeyboardMapping() {\n    const system = new KeyboardMappingSystem(\n      this._entityManager,\n      new KeyboardMappingSubSystemFactory(\n        this._engine.input,\n        this._engine.eventSystem\n      )\n    )\n\n    const { player1, player2 } = this._entityList\n    ;[player1, player2].forEach((entity) => {\n      system.registerEntityByName(entity.id)\n    })\n\n    this._engine.initLogicSystemManager.add('keyboardmapping', system)\n    return this\n  }\n```",
          "dateTime": "2024-02-12T12:24:58.651Z"
        },
        {
          "indexTitle": "MouseInput",
          "question": "MouseInput",
          "answer": "```typescript\nimport { IEntity, IManager } from 'engine_api'\nimport Direction from '../component/Direction'\nimport SystemBase from './core/SystemBase'\n\nconst MOUSE_MOVE_EVENT_TYPE = 'mousemove'\n\nexport class MouseInput extends SystemBase {\n  private _direction!: Direction\n\n  constructor(entityManager: IManager<IEntity>) {\n    super(entityManager)\n    this.initializeMouseInput()\n  }\n\n  start(): void {\n    this._direction = this._entity.getComponentStrict(Direction)\n  }\n\n  private initializeMouseInput() {\n    document.addEventListener(\n      MOUSE_MOVE_EVENT_TYPE,\n      this.handleMouseMove.bind(this)\n    )\n  }\n\n  private handleMouseMove(event: MouseEvent) {\n    const mouseX = event.clientX\n    const mouseY = event.clientY\n\n    const directionX = mouseX - window.innerWidth / 2\n    const directionY = mouseY - window.innerHeight / 2\n\n    this._direction.direction.x = directionX\n    this._direction.direction.y = directionY\n  }\n\n  unsubscribe() {\n    document.removeEventListener(\n      MOUSE_MOVE_EVENT_TYPE,\n      this.handleMouseMove.bind(this)\n    )\n  }\n}\n```",
          "dateTime": "2024-02-12T14:56:00.898Z"
        }
      ]
    },
    {
      "title": "System->Collision",
      "chats": [
        {
          "indexTitle": "engine_api",
          "question": "Engine Api",
          "answer": "```plaintext\n|-- engine_api\n|   |-- src\n|       |-- ecs\n|           |-- system\n|               |-- collision\n|                   |-- detector\n|                       |-- ICollision.ts\n|                       |-- ICollisionAlgorithm.ts\n|                       |-- ICollisionCallback.ts\n|                       |-- ICollisionDetector.ts\n|                       |-- ICollisionEntity.ts\n|                       |-- IRect.ts\n|                   |-- handler\n|                       |-- ICollisionHandler.ts\n```\n```typescript\nimport ICollisionEntity from './ICollisionEntity'\n\nexport default interface ICollision {\n  object1: ICollisionEntity\n  object2: ICollisionEntity\n}\n```\n```typescript\nimport ICollision from './ICollision'\n\nexport default interface ICollisionAlgorithm {\n  start(collision: ICollision): void\n  isColliding(): boolean\n}\n```\n```typescript\nimport ICollision from './ICollision'\n\nexport default interface ICollisionCallback {\n  (collision: ICollision): void\n}\n```\n```typescript\nimport ICollision from './ICollision'\nimport ICollisionCallback from './ICollisionCallback'\n\nexport default interface ICollisionDetector {\n  start(collision: ICollision): void\n  update(): void\n  subscribe(\n    collisionCallback: ICollisionCallback,\n    noCollisionCallback: ICollisionCallback\n  ): void\n}\n```\n```typescript\nimport IBoxCollider from '../../../component/IBoxCollider'\nimport IRigidBody from '../../../component/IRigidBody'\nimport ITransform from '../../../component/ITransform'\n\nexport default interface ICollisionEntity {\n  entityId: string\n  transform: ITransform\n  collider: IBoxCollider\n  rigidBody: IRigidBody\n}\n```\n```typescript\nimport { IVector2 } from '../../../../math'\n\nexport default interface IRect {\n  position: IVector2\n  size: IVector2\n}\n```\n```typescript\nimport ICollision from '../detector/ICollision'\n\nexport default interface ICollisionHandler {\n  onCollisionHandler(collision: ICollision): void\n  offCollisionHandler(collision: ICollision): void\n}\n```",
          "dateTime": "2024-02-20T22:29:56.192Z"
        },
        {
          "indexTitle": "engine->detector",
          "question": "Engine Detector",
          "answer": "```plaintext\n|-- engine\n|   |-- src\n|       |-- ecs\n|           |-- system\n|               |-- collision\n|                   |-- detector\n|                       |-- CenterCollision.ts\n|                       |-- CollisionDetector.ts\n|                       |-- TopLeftCollision.ts\n```\n```typescript\nimport { ICollision, ICollisionAlgorithm, IRect, IVector2 } from 'engine_api'\nimport Vector2 from '../../../../math/vector/Vector2'\n\nexport default class CenterCollision implements ICollisionAlgorithm {\n  private _rect1!: IRect\n  private _rect2!: IRect\n  private _collision!: ICollision\n  private _point1!: IVector2\n  private _point2!: IVector2\n\n  start(collision: ICollision) {\n    this._collision = collision\n    const { position: position1 } = collision.object1.transform\n    const { position: position2 } = collision.object2.transform\n    const {\n      halfSize: halfSize1,\n      center: center1,\n      size: size1,\n    } = collision.object1.collider\n    const {\n      halfSize: halfSize2,\n      center: center2,\n      size: size2,\n    } = collision.object2.collider\n\n    this._point1 = new Vector2(center1.x - halfSize1.x, center1.y - halfSize1.y)\n    this._point2 = new Vector2(center2.x - halfSize2.x, center2.y - halfSize2.y)\n    this._rect1 = this.createRect(position1, this._point1, size1)\n    this._rect2 = this.createRect(position2, this._point2, size2)\n  }\n\n  private createRect(\n    position: IVector2,\n    point: IVector2,\n    size: IVector2\n  ): IRect {\n    const rect: IRect = {} as IRect\n\n    rect.position = new Vector2(position.x + point.x, position.y + point.y)\n\n    rect.size = new Vector2(size.x, size.y)\n\n    return rect\n  }\n\n  private updatePoints() {\n    const p1 = this._collision.object1.transform.position\n    const p2 = this._collision.object2.transform.position\n\n    this.updatePosition(this._rect1, p1, this._point1)\n    this.updatePosition(this._rect2, p2, this._point2)\n  }\n\n  private updatePosition(rect: IRect, pos: IVector2, point: IVector2) {\n    rect.position.x = pos.x + point.x\n    rect.position.y = pos.y + point.y\n  }\n\n  isColliding(): boolean {\n    this.updatePoints()\n    return (\n      this._rect1.position.x < this._rect2.position.x + this._rect2.size.x &&\n      this._rect1.position.x + this._rect1.size.x > this._rect2.position.x &&\n      this._rect1.position.y < this._rect2.position.y + this._rect2.size.y &&\n      this._rect1.position.y + this._rect1.size.y > this._rect2.position.y\n    )\n  }\n}\n```\n```typescript\nimport { ICollision, ICollisionAlgorithm, ICollisionCallback } from 'engine_api'\n\nexport default class CollisionDetector {\n  private _collisionCallbacks: Map<string, ICollisionCallback> = new Map()\n  private _noCollisionCallbacks: Map<string, ICollisionCallback> = new Map()\n  private _collision!: ICollision\n  private _key!: string\n\n  constructor(private readonly _collisionAlgorithm: ICollisionAlgorithm) {}\n\n  start(collision: ICollision): void {\n    this._collision = collision\n    this._collisionAlgorithm.start(collision)\n    this._key = this.getCollisionKey()\n  }\n\n  private getCollisionKey(): string {\n    const id1 = this._collision.object1.entityId\n    const cid1 = this._collision.object1.collider.id\n    const id2 = this._collision.object2.entityId\n    return `${id1}_${cid1}_${id2}`\n  }\n\n  update() {\n    const isColliding = this._collisionAlgorithm.isColliding()\n\n    if (isColliding) {\n      const callback = this._collisionCallbacks.get(this._key)\n      if (callback) {\n        callback(this._collision)\n      }\n    } else {\n      const callback = this._noCollisionCallbacks.get(this._key)\n      if (callback) {\n        callback(this._collision)\n      }\n    }\n  }\n\n  subscribe(\n    collisionCallback: ICollisionCallback,\n    noCollisionCallback: ICollisionCallback\n  ): void {\n    this._collisionCallbacks.set(this._key, collisionCallback)\n    this._noCollisionCallbacks.set(this._key, noCollisionCallback)\n  }\n}\n```\n```typescript\nimport { ICollision, ICollisionAlgorithm, IRect } from 'engine_api'\n\nexport default class TopLeftCollision implements ICollisionAlgorithm {\n  private _rect1!: IRect\n  private _rect2!: IRect\n\n  start(collision: ICollision) {\n    const {\n      transform: { position: pos1 },\n      collider: { size: size1 },\n    } = collision.object1\n    const {\n      transform: { position: pos2 },\n      collider: { size: size2 },\n    } = collision.object2\n\n    this._rect1 = {\n      position: pos1,\n      size: size1,\n    }\n\n    this._rect2 = {\n      position: pos2,\n      size: size2,\n    }\n  }\n\n  isColliding(): boolean {\n    const p1 = this._rect1.position\n    const p2 = this._rect2.position\n    const s1 = this._rect1.size\n    const s2 = this._rect2.size\n    return (\n      p1.x < p2.x + s2.x &&\n      p1.x + s1.x > p2.x &&\n      p1.y < p2.y + s2.y &&\n      p1.y + s1.y > p2.y\n    )\n  }\n}\n```",
          "dateTime": "2024-02-20T22:30:20.897Z"
        },
        {
          "indexTitle": "engine->collision",
          "question": "Engine Collision System",
          "answer": "```plaintext\n|-- engine\n|   |-- src\n|       |-- ecs\n|           |-- system\n|               |-- collision\n|                   |-- CollisionSystem.ts\n|                   |-- InsideBoxCollisionSystem.ts\n|                   |-- LimitMoveSystem.ts\n```\n```typescript\nimport {\n  ICollisionHandler,\n  IEntityManager,\n  IEntity,\n  ICollision,\n  ICollisionEntity,\n} from 'engine_api'\nimport BoxCollider from '../../component/BoxCollider'\nimport CollisionObject from '../../component/CollisionObject'\nimport RigidBody from '../../component/RigidBody'\nimport Transform from '../../component/Transform'\nimport SystemBase from '../core/SystemBase'\nimport CollisionDetector from './detector/CollisionDetector'\n\nexport default class CollisionSystem extends SystemBase {\n  protected _collision: ICollision = {\n    object1: {} as ICollisionEntity,\n    object2: {} as ICollisionEntity,\n  }\n  protected _entity2!: IEntity\n  protected _boxColliderId: string = ''\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _collisionDetector: CollisionDetector,\n    private readonly _collisionHandler: ICollisionHandler\n  ) {\n    super(entityManager)\n  }\n\n  start() {\n    this.setBoxColliderId()\n    this.setObject1()\n    this._entity2 = this.setEntity2()\n    this.setObject2()\n    this._collisionDetector.start(this._collision)\n    this._collisionDetector.subscribe(\n      this._collisionHandler.onCollisionHandler.bind(this._collisionHandler),\n      this._collisionHandler.offCollisionHandler.bind(this._collisionHandler)\n    )\n  }\n\n  protected setBoxColliderId() {}\n\n  private setObject1() {\n    this._collision.object1 = {\n      entityId: this._entity.id,\n      collider:\n        this._boxColliderId === ''\n          ? this._entity.getComponentStrict(BoxCollider)\n          : this._entity.getComponentStrict(BoxCollider, this._boxColliderId),\n      rigidBody: this._entity.getComponentStrict(RigidBody),\n      transform: this._entity.getComponentStrict(Transform),\n    }\n  }\n\n  private setEntity2() {\n    return this._entityManager.getStrict(\n      this._entity.getComponentStrict(CollisionObject).objectIdToCollideWith\n    )\n  }\n\n  private setObject2() {\n    this._collision.object2 = {\n      entityId: this._entity2.id,\n      collider: this._entity2.getComponentStrict(BoxCollider),\n      rigidBody: this._entity2.getComponentStrict(RigidBody),\n      transform: this._entity2.getComponentStrict(Transform),\n    }\n  }\n\n  update(_deltaTime: number): void {\n    this._collisionDetector.update()\n  }\n}\n```\n```typescript\nimport Transform from '../../component/Transform'\nimport RigidBody from '../../component/RigidBody'\nimport CircleCollider from '../../component/CircleCollider'\nimport InsideBoxCollider from '../../component/InsideBoxCollider'\nimport SystemBase from '../core/SystemBase'\n\nenum Axis {\n  X = 'x',\n  Y = 'y',\n}\n\nexport default class InsideBoxCollisionSystem extends SystemBase {\n  private _rigidBody!: RigidBody\n  private _transform!: Transform\n  private _circleCollider!: CircleCollider\n  private _insideBoxCollider!: InsideBoxCollider\n\n  start(): void {\n    this._rigidBody = this._entity.getComponentStrict(RigidBody)\n    this._transform = this._entity.getComponentStrict(Transform)\n    this._circleCollider = this._entity.getComponentStrict(CircleCollider)\n    this._insideBoxCollider = this._entity.getComponentStrict(InsideBoxCollider)\n  }\n\n  update(_deltaTime: number) {\n    ;[Axis.X, Axis.Y].forEach((axis: any) => {\n      this.checkAndHandleCollision(axis)\n    })\n  }\n\n  private checkAndHandleCollision(axis: Axis) {\n    const position = this._transform.position[axis]\n    const radius = this._circleCollider.radius\n    const wallPosition = this._insideBoxCollider.size[axis]\n\n    if (this.isCollisionDetected(position, radius, wallPosition)) {\n      this.resolveCollision(radius, wallPosition, axis)\n    }\n  }\n\n  private isCollisionDetected(\n    position: number,\n    radius: number,\n    maxlimit: number,\n    minLimit: number = 0\n  ): boolean {\n    return position - radius <= minLimit || position + radius >= maxlimit\n  }\n\n  private resolveCollision(radius: number, maxLimit: number, axis: Axis) {\n    this._rigidBody.velocity[axis] *= -1\n    this._transform.position[axis] = this.adjustPosition(\n      this._transform.position[axis],\n      radius,\n      maxLimit\n    )\n  }\n\n  private adjustPosition(\n    position: number,\n    radius: number,\n    limit: number\n  ): number {\n    return Math.max(radius, Math.min(limit - radius, position))\n  }\n}\n```\n```typescript\nimport LimitMove from '../../component/LimitMove'\nimport Transform from '../../component/Transform'\nimport BoxCollider from '../../component/BoxCollider'\nimport SystemBase from '../core/SystemBase'\n\nexport default class LimitMoveSystem extends SystemBase {\n  private _limitMove!: LimitMove\n  private _boxCollider!: BoxCollider\n  private _transform!: Transform\n\n  start(): void {\n    this._limitMove = this._entity.getComponentStrict(LimitMove)\n    this._boxCollider = this._entity.getComponentStrict(BoxCollider, 'body')\n    this._transform = this._entity.getComponentStrict(Transform)\n  }\n\n  update(_deltaTime: number) {\n    const { x: offsetX, y: offsetY } = this._boxCollider.center\n\n    const halfWidth = this._boxCollider.halfSize.x\n    const halfHeight = this._boxCollider.halfSize.y\n\n    const newX = Math.max(\n      halfWidth + offsetX,\n      Math.min(\n        this._limitMove.limitSize.x - halfWidth - offsetX,\n        this._transform.position.x\n      )\n    )\n    const newY = Math.max(\n      halfHeight - offsetY,\n      Math.min(\n        this._limitMove.limitSize.y - halfHeight - offsetY,\n        this._transform.position.y\n      )\n    )\n\n    this._transform.position.x = newX\n    this._transform.position.y = newY\n  }\n}\n```",
          "dateTime": "2024-02-20T22:30:43.672Z"
        },
        {
          "indexTitle": "ball_game->collision",
          "question": "ball_game->collision",
          "answer": "```plaintext\n|-- ball_game\n|   |-- src\n|       |-- collision\n|           |-- PlayerBootsBallCollision.ts\n|           |-- PlayerKickBallCollision.ts\n```\n```typescript\nimport { CollisionSystem } from 'engine'\n\nexport class PlayerBootsBallCollision extends CollisionSystem {\n  protected setBoxColliderId() {\n    this._boxColliderId = 'boots'\n  }\n}\n```\n```typescript\nimport { CollisionSystem } from 'engine'\n\nexport class PlayerKickBallCollision extends CollisionSystem {\n  protected setBoxColliderId() {\n    this._boxColliderId = 'kick'\n  }\n}\n```",
          "dateTime": "2024-02-20T22:22:04.177Z"
        },
        {
          "indexTitle": "ball_game->collision_handler",
          "question": "ball_game->collision_handler",
          "answer": "```plaintext\n|-- ball_game\n|   |-- src\n|       |-- collision_handler\n|           |-- BallGateCollisionHandler.ts\n|           |-- PlayerBootsBallCollisionHandler.ts\n|           |-- PlayerKickBallCollisionHandler.ts\n```\n```typescript\nimport {\n  ICollisionHandler,\n  IEntityManager,\n  IManager,\n  IEntityDataModel,\n  IEventSystem,\n  ICollisionInfo,\n  IScoreInfo,\n} from 'engine_api'\nimport {\n  Transform,\n  RigidBody,\n  Vector2,\n  componentType,\n  EventNames,\n  GameState,\n  IdleState,\n  EntityId,\n} from 'engine'\n\nexport default class BallGateCollisionHandler implements ICollisionHandler {\n  constructor(\n    private readonly _entityManager: IEntityManager,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _eventSystem: IEventSystem\n  ) {}\n\n  handleCollision(collisionInfo: ICollisionInfo) {\n    this.resetEntities()\n    this.updateEntitiesPositions()\n    this.handleGateCollisions(collisionInfo)\n  }\n\n  handleNoCollision(collisionInfo: ICollisionInfo) {}\n\n  private resetEntities() {\n    this.resetEntity(EntityId.Player1)\n    this.resetEntity(EntityId.Player2)\n    this.resetEntity(EntityId.Ball)\n  }\n\n  private resetEntity(entityId: string) {\n    const entityData = this._entityDataManager.getStrict(entityId)\n    const entity = this._entityManager.getStrict(entityId)\n    const transform = entity.getComponentStrict(Transform)\n    const rigidBody = entity.getComponentStrict(RigidBody)\n\n    rigidBody.velocity = new Vector2()\n    transform.position = Vector2.getNew(\n      entityData[componentType.Transform].position\n    )\n  }\n\n  private updateEntitiesPositions() {\n    this.updateEntityPosition(EntityId.Player1)\n    this.updateEntityPosition(EntityId.Player2)\n    this.updateEntityPosition(EntityId.Ball)\n  }\n\n  private updateEntityPosition(entityId: string) {\n    const entityData = this._entityDataManager.getStrict(entityId)\n    const entity = this._entityManager.getStrict(entityId)\n    const transform = entity.getComponentStrict(Transform)\n\n    transform.position = Vector2.getNew(\n      entityData[componentType.Transform].position\n    )\n  }\n\n  private handleGateCollisions(collisionInfo: ICollisionInfo) {\n    const gameState = this._entityManager\n      .getStrict(EntityId.GameState)\n      .getComponentStrict(GameState)\n\n    if (collisionInfo.object1.entityId === EntityId.LeftGate) {\n      this.handleLeftGateCollision(gameState)\n    }\n\n    if (collisionInfo.object1.entityId === EntityId.RightGate) {\n      this.handleRightGateCollision(gameState)\n    }\n  }\n\n  private handleLeftGateCollision(gameState: GameState) {\n    gameState.score.blueScore++\n    this.publishScore(gameState)\n    this.publishIdle()\n  }\n\n  private handleRightGateCollision(gameState: GameState) {\n    gameState.score.redScore++\n    this.publishScore(gameState)\n    this.publishIdle()\n  }\n\n  private publishScore(gameState: GameState) {\n    this._eventSystem.publish(EventNames.UpdateScore, {\n      redScore: gameState.score.redScore,\n      blueScore: gameState.score.blueScore,\n    } as IScoreInfo)\n  }\n\n  private publishIdle() {\n    this._eventSystem.publish(EventNames.ChangeState, {\n      id: EntityId.Ball,\n      newState: new IdleState(this._eventSystem),\n    })\n  }\n}\n```\n```typescript\nimport { EventNames, MoveState } from 'engine'\nimport { ICollisionHandler, ICollisionInfo, IEventSystem } from 'engine_api'\n\nexport default class PlayerBootsBallCollisionHandler\n  implements ICollisionHandler\n{\n  constructor(private readonly _eventSystem: IEventSystem) {}\n\n  handleCollision(collisionInfo: ICollisionInfo) {\n    const obj1 = collisionInfo.object1.rigidBody\n    const obj2 = collisionInfo.object2.rigidBody\n\n    const relativeV = obj2.velocity.clone().subtract(obj1.velocity)\n\n    const obj2MassFactor = (2 * obj1.mass) / (obj1.mass + obj2.mass)\n\n    const newObj2Velocity = obj2.velocity\n      .clone()\n      .subtract(relativeV.clone())\n      .multiply(obj2MassFactor)\n      .multiply(obj2.cor)\n\n    obj2.velocity\n      .setValues(newObj2Velocity)\n      .multiply(obj2.speedMultiplier)\n      .clampLength(0, obj2.maxSpeed)\n\n    this._eventSystem.publish(EventNames.StoreLastCollisionInfo, collisionInfo)\n    if (Math.abs(obj2.velocity.x) > 0 || Math.abs(obj2.velocity.y) > 0)\n      this._eventSystem.publish(EventNames.ChangeState, {\n        id: collisionInfo.object2.entityId,\n        newState: new MoveState(this._eventSystem),\n      })\n  }\n\n  handleNoCollision(collisionInfo: ICollisionInfo) {}\n}\n```\n```typescript\nimport { ICollisionHandler, ICollisionInfo, IEventSystem } from 'engine_api'\n\nexport default class PlayerKickBallCollisionHandler\n  implements ICollisionHandler\n{\n  constructor(private readonly _eventSystem: IEventSystem) {}\n\n  handleCollision(collisionInfo: ICollisionInfo) {\n    this._eventSystem.publish('kickOn', {\n      id: collisionInfo.object1.entityId,\n    })\n  }\n\n  handleNoCollision(collisionInfo: ICollisionInfo) {\n    this._eventSystem.publish('kickOff', {\n      id: collisionInfo.object1.entityId,\n    })\n  }\n}\n```",
          "dateTime": "2024-02-20T22:22:54.950Z"
        },
        {
          "indexTitle": "ball_game->GameSystemBuilder",
          "question": "ball_game->GameSystemBuilder",
          "answer": "```typescript\nwithPlayerBallCollision() {\n    const bootsHandler = new PlayerBootsBallCollisionHandler(\n      this._engine.eventSystem\n    )\n    const kickHandler = new PlayerKickBallCollisionHandler(\n      this._engine.eventSystem\n    )\n    const { player1, player2 } = this._entityList\n    ;[player1, player2].forEach((player) => {\n      this.createPlayerBallCollider(\n        this.getBootsBallCollider(bootsHandler),\n        player,\n        'boots_ball'\n      )\n      this.createPlayerBallCollider(\n        this.getKickBallCollider(kickHandler),\n        player,\n        'kick_ball'\n      )\n    })\n\n    return this\n  }\n\n  private createPlayerBallCollider(\n    system: ISystem,\n    player: IEntity,\n    sytemId: string\n  ) {\n    system.registerEntityById(player.id)\n    system.start()\n    this._engine.systemManager.add(`${sytemId}_${player.id}`, system)\n  }\n\n  private getBootsBallCollider(handler: ICollisionHandler) {\n    return new PlayerBootsBallCollision(\n      this._engine.entityManager,\n      new CollisionDetector(new CenterCollision()),\n      handler\n    )\n  }\n\n  private getKickBallCollider(handler: ICollisionHandler) {\n    return new PlayerKickBallCollision(\n      this._engine.entityManager,\n      new CollisionDetector(new CenterCollision()),\n      handler\n    )\n  }\n```",
          "dateTime": "2024-02-20T22:55:40.715Z"
        }
      ]
    },
    {
      "title": "Data Loaders",
      "chats": [
        {
          "indexTitle": "Entity Loader v2",
          "question": "Entity Loader v2",
          "answer": "```typescript\nexport const componentList: Record<string, string> = {\n  transform: 'transform',\n  boxCollider: 'boxCollider',\n  sprite: 'sprite',\n  rigidBody: 'rigidBody',\n}\n```\n```typescript\nimport { BoxCollider, RigidBody, Sprite, Transform, Vector2 } from 'engine'\nimport { IBoxCollider, IRigidBody, ISprite, ITransform } from 'engine_api'\nimport IComponentMapper from './IComponentMapper'\n\nexport default class ComponentMapper implements IComponentMapper {\n  builders: Record<string, (data: any) => any> = {\n    transform: this.mapTransform,\n    boxCollider: this.mapBoxCollider,\n    sprite: this.mapSprite,\n    rigidBody: this.mapRigidBody,\n  }\n\n  private mapTransform(data: ITransform) {\n    console.log('Building transform')\n    const d = data\n    const c = new Transform()\n    c.position = d.position\n    c.rotation = d.rotation\n    c.scale = d.scale\n    return c\n  }\n\n  private mapBoxCollider(data: IBoxCollider) {\n    console.log('Building boxCollider')\n    const d = data\n    const c = new BoxCollider()\n    c.center = d.center\n    c.color = d.color\n    c.enableRender = d.enableRender\n    c.isTrigger = d.isTrigger\n    c.material = d.material\n    c.size = d.size\n    return c\n  }\n\n  private mapSprite(data: ISprite) {\n    console.log('Building sprite')\n    const d = data\n    const c = new Sprite()\n    c.spriteOffset = d.spriteOffset\n    c.isFlipped = d.isFlipped\n    c.spriteAnimation = d.spriteAnimation\n    c.state = d.state\n    return c\n  }\n\n  private mapRigidBody(data: IRigidBody) {\n    console.log('Building rigidBody')\n    const d = data\n    const c = new RigidBody()\n    //todo test this:\n    //c.velocity = d.velocity\n    c.velocity = Vector2.getNew(d.velocity)\n    c.mass = d.mass\n    c.cor = d.cor\n    c.speedMultiplier = d.speedMultiplier\n    c.maxSpeed = d.maxSpeed\n    c.moveStep = d.moveStep\n    c.useArrowKeys = d.useArrowKeys\n    c.stopThreshold = d.stopThreshold\n    return c\n  }\n}\n```\n```typescript\nimport { IEntity, IManager } from 'engine_api'\n\nexport default class DataPrinter {\n  printData(data: Record<string, any>) {\n    console.log('Printing file data:')\n    console.log('Data Type:', typeof data)\n    console.log('Loaded Data:', data)\n  }\n\n  printKeysAndValues(data: Record<string, any>) {\n    console.log('Printing keys and values:')\n    for (const key in data) {\n      if (data.hasOwnProperty(key)) {\n        console.log('Key:', key)\n        console.log('Item:', data[key])\n      }\n    }\n  }\n\n  printValues(data: Record<string, any>) {\n    console.log('Printing values:')\n    const values = Object.values(data)\n    for (const item of values) {\n      console.log('Item:', item)\n    }\n  }\n\n  printEntity(manager: IManager<IEntity>) {\n    manager.forEach((key, entity) => console.log(key, ':', entity))\n  }\n}\n```\n```typescript\nimport { Entity, MapManager } from 'engine'\nimport { IEntity } from 'engine_api'\nimport IComponentMapper from './IComponentMapper'\nimport { componentList } from './componentList'\n\nexport default class EntityComponentCreator {\n  constructor(private readonly _componentBuilder: IComponentMapper) {}\n\n  createEntityManager(data: { [key: string]: Record<string, any> }) {\n    const entityManager = new MapManager<IEntity>()\n    for (const key in data) {\n      const entity = new Entity()\n      entity.id = key\n      entityManager.add(key, entity)\n      this.createEntityComponents(data[key], entity)\n    }\n    return entityManager\n  }\n\n  private createEntityComponents(data: Record<string, any>, entity: IEntity) {\n    for (const key in data) {\n      const componentType = componentList[key]\n      if (componentType) {\n        const componentBuild = this._componentBuilder.builders[componentType](\n          data[key]\n        )\n        if (componentBuild) entity.addComponent(componentBuild)\n        else console.warn(`Unsupported builder for component type: ${key}`)\n      } else console.warn(`Unsupported component type: ${key}`)\n    }\n  }\n}\n```\n```typescript\nimport ComponentMapper from './ComponentMapper'\nimport DataPrinter from './DataPrinter'\nimport EntityComponentCreator from './EntityComponentCreator'\nimport FileLoader from './FileLoader'\n\nexport default class EntityManagerInitializer {\n  private isDataPrintOn: boolean\n  private fileLoader: FileLoader\n  private data: any // Assuming the type of data, adjust as needed\n  private printer: DataPrinter\n  private entityManager: any // Adjust the type according to your EntityManager\n\n  constructor(isDataPrintOn: boolean) {\n    this.isDataPrintOn = isDataPrintOn\n    this.fileLoader = new FileLoader('./data/entityFormat.json')\n    this.data = null\n    this.printer = new DataPrinter()\n    this.entityManager = null\n  }\n\n  async initialize(): Promise<void> {\n    this.data = await this.fileLoader.getData()\n\n    if (this.isDataPrintOn) {\n      this.printData()\n      this.printKeysAndValues()\n      this.printValues()\n    }\n\n    this.initializeEntityManager()\n    this.printEntity()\n  }\n\n  private printData(): void {\n    this.printer.printData(this.data)\n  }\n\n  private printKeysAndValues(): void {\n    this.printer.printKeysAndValues(this.data)\n  }\n\n  private printValues(): void {\n    this.printer.printValues(this.data)\n  }\n\n  private initializeEntityManager(): void {\n    const entityComponentCreator = new EntityComponentCreator(\n      new ComponentMapper()\n    )\n    this.entityManager = entityComponentCreator.createEntityManager(this.data)\n  }\n\n  private printEntity(): void {\n    this.printer.printEntity(this.entityManager)\n  }\n}\n\nexport async function testEntityBuildingFromJsonData() {\n  const isDataPrintOn: boolean = false\n  const entityManagerInitializer = new EntityManagerInitializer(isDataPrintOn)\n  await entityManagerInitializer.initialize()\n}\n```\n```typescript\nimport { JsonObjectLoader } from 'engine'\n\nexport default class FileLoader {\n  constructor(private readonly _filePath: string) {}\n\n  async getData(): Promise<Record<string, any>> {\n    const dataLoader = new JsonObjectLoader<Record<string, any>>(this._filePath)\n    try {\n      return await dataLoader.getData()\n    } catch (error) {\n      console.error('Error getting data:', error)\n      throw error\n    }\n  }\n}\n```\n```typescript\nexport default interface IComponentMapper {\n  builders: Record<string, (data: any) => any>\n}\n```",
          "dateTime": "2024-02-08T23:22:39.608Z"
        }
      ]
    },
    {
      "title": "Obsolete",
      "chats": [
        {
          "indexTitle": "InitLogicSystem",
          "question": "InitLogicSystem",
          "answer": "* After part of tutorial in unity i removed that  \n* It was replaced with start method in SystemBase class  \n* Now only one entity can be registered to SystemBase  \ndue to need of storing of entity components at initialization with start  \ndoing that for collection would be needlesly complex  \nBetter to do it for one entity per system and have collection of systems for entities  \nthat system with collection of entities althou that may be nessecery  \nfor entities that are storonglly related in context of a system   \n```plaintext\n|-- engine/\n|   |-- src/\n|       |-- ecs/\n|           |-- component/\n|           |-- entity/\n|           |-- system/\n|               |-- base/\n|                   |-- init_logic/\n|                       |-- IInitLogicSystem.ts\n|                       |-- IInitLogicSystemManager.ts\n|                       |-- InitLogicSystemBase.ts\n|                       |-- InitLogicSystemManager.ts\n```\n```typescript\nexport default interface IRegisterEntityByName {\n  registerEntityByName(name: string): void\n}\n```\n```typescript\nimport IRegisterEntityByName from '../IRegisterEntityByName'\n\nexport default interface IInitLogicSystem extends IRegisterEntityByName {\n  init(): void\n}\n```\n```typescript\nimport { IManager } from 'engine_api'\nimport IInitLogicSystem from './IInitLogicSystem'\n\nexport default interface IInitLogicSystemManager\n  extends IManager<IInitLogicSystem> {\n  init(): void\n}\n```  \n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport IInitLogicSystem from './IInitLogicSystem'\n\nexport default abstract class InitLogicSystemBase implements IInitLogicSystem {\n  protected _entityList: IEntity[] = []\n\n  constructor(protected readonly _entityManager: IEntityManager) {}\n\n  init(): void {\n    this.iterateEntities((entity) => this.initLogic(entity))\n  }\n\n  private iterateEntities(callback: (entity: IEntity) => void): void {\n    for (const entity of this._entityList) {\n      callback(entity)\n    }\n  }\n\n  abstract initLogic(entity: IEntity): void\n\n  registerEntityByName(name: string): void {\n    this._entityList.push(this._entityManager.getStrict(name))\n  }\n}\n```\n```typescript\nimport MapManager from '../../../../tech/entity_component/MapManager'\nimport IInitLogicSystem from './IInitLogicSystem'\nimport IInitLogicSystemManager from './IInitLogicSystemManager'\n\nexport default class InitLogicSystemManager\n  extends MapManager<IInitLogicSystem>\n  implements IInitLogicSystemManager\n{\n  init(): void {\n    for (const system of this.values()) {\n      system.init()\n    }\n  }\n}\n```",
          "dateTime": "2024-02-12T12:28:39.585Z"
        },
        {
          "indexTitle": "RenderSystem",
          "question": "RenderSystem",
          "answer": "```typescript\nimport { IRegisterEntityByName } from 'engine_api'\n\nexport default interface IRenderSystem extends IRegisterEntityByName {\n  render(deltaTime: number): void\n}\n```\n```typescript\nimport { IManager } from 'engine_api'\nimport IRenderSystem from './IRenderSystem'\n\nexport default interface IRenderSystemManager extends IManager<IRenderSystem> {\n  render(deltaTime: number): void\n}\n```\n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport IRenderSystem from './IRenderSystem'\n\nexport default abstract class RenderSystemBase implements IRenderSystem {\n  protected entityList: IEntity[] = []\n\n  constructor(protected readonly entityManager: IEntityManager) {}\n\n  render(deltaTime: number): void {\n    this.iterateEntities((entity) => this.renderLogic(deltaTime, entity))\n  }\n\n  private iterateEntities(callback: (entity: IEntity) => void): void {\n    for (const entity of this.entityList) {\n      callback(entity)\n    }\n  }\n\n  abstract renderLogic(deltaTime: number, entity: IEntity): void\n\n  registerEntityByName(name: string): void {\n    this.entityList.push(this.entityManager.getStrict(name))\n  }\n}\n```\n```typescript\nimport MapManager from '../../../entity/manager/MapManager'\nimport IRenderSystem from './IRenderSystem'\nimport IRenderSystemManager from './IRenderSystemManager'\n\nexport default class RenderSystemManager\n  extends MapManager<IRenderSystem>\n  implements IRenderSystemManager\n{\n  render(dt: number): void {\n    for (const system of this.values()) {\n      system.render(dt)\n    }\n  }\n}\n```\n```typescript\nimport {\n  IEntity,\n  IEventSystem,\n  IManager,\n  IRenderable,\n  IRendererV2,\n  IVector2,\n} from 'engine_api'\nimport IRenderSubSystem from './IRenderSubSystem'\nimport SpriteAnimator from '../../sprite/SpriteAnimator'\nimport GameState from '../component/GameState'\nimport Vector2 from '../../math/vector/Vector2'\nimport Map from '../component/Map'\nimport { EventNames } from '../../event_system/EventNames'\nimport Sprite from '../component/Sprite'\nimport Transform from '../component/Transform'\nimport BoxCollider from '../component/BoxCollider'\nimport RigidBody from '../component/RigidBody'\nimport Direction from '../component/Direction'\n\nexport default class RenderSubSystem implements IRenderSubSystem {\n  private _offset1: IVector2 = new Vector2(20, 0)\n  private _offset2: IVector2 = new Vector2(15, 0)\n\n  constructor(\n    private readonly _renderer: IRendererV2,\n    private readonly _spriteAnimatorManager: IManager<SpriteAnimator>,\n    private readonly _tileMap: IRenderable,\n    private readonly _eventSystem: IEventSystem\n  ) {}\n\n  addSprite(entity: IEntity): void {\n    const sprite = entity.getComponentStrict(Sprite)\n\n    this._spriteAnimatorManager.add(\n      entity.id,\n      new SpriteAnimator(sprite.spriteAnimation)\n    )\n\n    this._eventSystem.subscribe(\n      EventNames.AnimationSwitch,\n      (data: { id: string; animId: number }) => {\n        this._spriteAnimatorManager\n          .getStrict(data.id)\n          .switchAnimation(data.animId)\n      }\n    )\n  }\n\n  renderLogic(deltaTime: number, entity: IEntity) {\n    const sprite = entity.getComponent(Sprite)\n    const transform = entity.getComponent(Transform)\n    const boxCollider = entity.getComponent(BoxCollider)\n    const body = entity.getComponent(BoxCollider, 'body')\n    const boots = entity.getComponent(BoxCollider, 'boots')\n    const direction = entity.getComponent(Direction)\n    const rigidBody = entity.getComponent(RigidBody)\n    const gameState = entity.getComponent(GameState)\n    const map = entity.getComponent(Map)\n\n    if (sprite && transform) {\n      if (sprite.spriteAnimation.length > 0) {\n        const animator = this._spriteAnimatorManager.getStrict(entity.id)\n        animator.update(deltaTime)\n        animator.draw(\n          this._renderer.ctx,\n          transform.position.x + sprite.spriteOffset.x,\n          transform.position.y + sprite.spriteOffset.y,\n          sprite.isFlipped\n        )\n      }\n    }\n\n    if (\n      boxCollider &&\n      boxCollider.enableRender &&\n      transform &&\n      rigidBody &&\n      direction\n    ) {\n      this._renderer.drawObject(transform, boxCollider, rigidBody, direction)\n    }\n\n    if (body && body.enableRender && transform) {\n      this._renderer.drawCollisionBox(transform, body)\n    }\n    if (boots && boots.enableRender && transform) {\n      this._renderer.drawCollisionBox(transform, boots)\n    }\n\n    if (gameState) {\n      this._renderer.drawText(':', gameState.position, 'yellow', '20px Arial')\n\n      this._renderer.drawText(\n        gameState.score.redScore.toString(),\n        new Vector2(\n          gameState.position.x - this._offset1.x,\n          gameState.position.y\n        ),\n        'red',\n        '20px Arial'\n      )\n\n      this._renderer.drawText(\n        gameState.score.blueScore.toString(),\n        new Vector2(\n          gameState.position.x + this._offset2.x,\n          gameState.position.y\n        ),\n        'blue',\n        '20px Arial'\n      )\n    }\n\n    if (map) {\n      this._tileMap.render(deltaTime)\n    }\n  }\n}\n```\n```typescript\nimport { IEntity, IEntityManager } from 'engine_api'\nimport RenderSystemBase from './render/RenderSystemBase'\nimport IRenderSubSystem from './IRenderSubSystem'\n\nexport default class RenderSystem extends RenderSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _renderSubSystem: IRenderSubSystem\n  ) {\n    super(entityManager)\n  }\n\n  renderLogic(deltaTime: number, entity: IEntity) {\n    this._renderSubSystem.renderLogic(deltaTime, entity)\n  }\n}\n```",
          "dateTime": "2024-02-15T17:03:18.562Z"
        },
        {
          "indexTitle": "Entity Data Loader",
          "question": "Entity Data Loader",
          "answer": "```typescript\nexport const EntityId = {\n  Field: 'field',\n  Player1: 'player1',\n  Player2: 'player2',\n  Ball: 'ball',\n  LeftGate: 'leftGate',\n  RightGate: 'rightGate',\n  GameState: 'gameState',\n} as const\n```\n```typescript\nimport {\n  IBoxCollider,\n  ICircleCollider,\n  ICollisionObject,\n  IComponent,\n  IEntity,\n  IEntityBuilder,\n  IEntityDataModel,\n  IEntityManager,\n  IGameState,\n  ILimitMove,\n  IManager,\n  IRigidBody,\n  ISprite,\n  ITransform,\n} from 'engine_api'\nimport Map from '../../component/Map'\nimport { OperationMap } from '../../../utils/operation/OperationMap'\nimport { Operation } from '../../../utils/operation/Operation'\nimport AssertHelper from '../../../utils/AssertionHelper'\nimport ClientMovement from '../../component/ClientMovement'\nimport ServerMovement from '../../component/ServerMovement'\nimport { componentType } from '../../component/core/componentType'\nimport IComponentMapper from '../IComponentMapper'\nimport ComponentMapper from '../ComponentMapper'\n\nexport default class EntityBuilder implements IEntityBuilder {\n  protected _entity!: IEntity\n  private _entityData!: IEntityDataModel\n  private _operationMap: OperationMap = new OperationMap()\n  private _assert: AssertHelper = new AssertHelper(this)\n  private _mapper: IComponentMapper = new ComponentMapper()\n\n  get entityData(): IEntityDataModel {\n    this.assertEntityData()\n    return this._entityData\n  }\n\n  constructor(\n    private readonly _dataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  recordOperation(operation: Operation): this {\n    this._operationMap.addOperation(operation)\n    return this\n  }\n\n  protected executeOperations(entityDatakey: string): void {\n    this._operationMap.executeOperations(entityDatakey)\n  }\n\n  private assertEntity(): void {\n    this._assert.assertField('_entity')\n  }\n\n  private assertEntityData(): void {\n    this._assert.assertField('_entityData')\n  }\n\n  withEntity<T extends IEntity>(entityFunction: () => T) {\n    this._entity = entityFunction()\n    return this\n  }\n\n  withMap(): this {\n    this._entity.addComponent(new Map())\n    return this\n  }\n\n  withEntityData(entityDataKey: string): this {\n    this.assertEntity()\n    this._entityData = this._dataManager.getStrict(entityDataKey)\n    this._entity.id = this._entityData.id\n    return this\n  }\n\n  withSprite(): this {\n    this.addComponent(this.map<ISprite>(componentType.Sprite))\n    return this\n  }\n\n  withClientMovement(): this {\n    this._entity.addComponent(new ClientMovement())\n    return this\n  }\n\n  withServerMovement(): this {\n    this._entity.addComponent(new ServerMovement())\n    return this\n  }\n\n  withCollisionObject() {\n    this.addComponent(this.map<ICollisionObject>(componentType.CollisionObject))\n    return this\n  }\n\n  withLimitMove() {\n    this.addComponent(this.map<ILimitMove>(componentType.LimitMove))\n    return this\n  }\n\n  withGameState() {\n    this.addComponent(this.map<IGameState>(componentType.GameState))\n    return this\n  }\n\n  withCircleCollider() {\n    this.addComponent(this.map<ICircleCollider>(componentType.CircleCollider))\n    return this\n  }\n\n  withInsideBoxCollider() {\n    this.addComponent(this.map<IBoxCollider>(componentType.InsideBoxCollider))\n    return this\n  }\n\n  private map<TComponent>(componentType: string): TComponent | TComponent[] {\n    return this._mapper.mappers[componentType](\n      this.getData<TComponent>(componentType)\n    ) as TComponent\n  }\n\n  private getData<TData>(componentType: string) {\n    this.assertEntityData()\n    const data = this._entityData[componentType]\n    if (Array.isArray(data)) {\n      return data as TData[]\n    } else {\n      return data as TData\n    }\n  }\n\n  withTransform() {\n    this.addComponent(this.map<ITransform>(componentType.Transform))\n    return this\n  }\n\n  withBoxCollider() {\n    this.addComponent(this.map<IBoxCollider>(componentType.BoxCollider))\n    return this\n  }\n\n  private addComponent(component: IComponent | IComponent[]) {\n    if (Array.isArray(component)) {\n      this._entity.addComponents(component)\n    } else {\n      this._entity.addComponent(component)\n    }\n  }\n\n  withRigidBody() {\n    this.addComponent(this.map<IRigidBody>(componentType.RigidBody))\n    return this\n  }\n\n  build(entityDataKey: string, entityKey: string) {\n    this.executeOperations(entityDataKey)\n    this.assertEntity()\n    this._entityManager.add(entityKey, this._entity)\n  }\n}\n```\n```typescript\nimport { IEntityCreator, IEntityBuilder } from 'engine_api'\nimport IEntityCreatorData from './IEntityCreatorData'\nimport ArrayDataLoader from '../../../../utils/data_loader/ArrayDataLoader'\n\nexport default class EntityCreator implements IEntityCreator {\n  private _builders: Map<string, IEntityBuilder> = new Map()\n  private _dataLoader = new ArrayDataLoader<IEntityCreatorData>(\n    'data/entityCreatorData.json'\n  )\n\n  addBuilder(key: string, builder: IEntityBuilder): void {\n    this._builders.set(key, builder)\n  }\n\n  protected build(key: string, entityDataKey: string, entityKey: string): void {\n    const builder = this._builders.get(key)\n    if (!builder) throw new Error(`Builder with key '${key}' not found.`)\n    builder.build(entityDataKey, entityKey)\n  }\n\n  async createEntities(): Promise<void> {\n    const dataArray = await this._dataLoader.getData()\n    dataArray.forEach((data) => {\n      this.build(data.builder, data.entityDataKey, data.entityKey)\n    })\n  }\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityBuilder,\n  IManager,\n  IEntityDataModel,\n} from 'engine_api'\n\nexport default class EntityCreatorFromCode implements IEntityCreator {\n  private _builders: Map<string, IEntityBuilder> = new Map()\n\n  constructor(\n    private readonly _entityDataManeger: IManager<IEntityDataModel>\n  ) {}\n\n  addBuilder(builderKey: string, builder: IEntityBuilder): void {\n    this._builders.set(builderKey, builder)\n  }\n\n  protected build(\n    builderKey: string,\n    entityDataKey: string,\n    entityKey: string\n  ): void {\n    const builder = this._builders.get(builderKey)\n    if (!builder) throw new Error(`Builder with key '${builderKey}' not found.`)\n    builder.build(entityDataKey, entityKey)\n  }\n\n  async createEntities(): Promise<void> {\n    this._entityDataManeger.forEach((objectkey, objectData) => {\n      this.build(objectData.builderKey, objectkey, objectData.id)\n    })\n  }\n}\n```\n```typescript\nexport default interface IEntityCreatorData {\n  builder: string\n  entityDataKey: string\n  entityKey: string\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityDataModel,\n  IEntityManager,\n  IManager,\n} from 'engine_api'\nimport EntityBuilder from '../EntityBuilder'\nimport ICustomEntityBuilder from './ICustomEntityBuilder'\nimport Entity from '../../../entity/Entity'\n\nexport default class BallBuilder implements ICustomEntityBuilder {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  withCustomEntityBuilder(builderKey: string) {\n    this._entityCreator.addBuilder(builderKey, this.getCustomEntityBuilder())\n  }\n\n  getCustomEntityBuilder() {\n    const builder = new EntityBuilder(\n      this._entityDataManager,\n      this._entityManager\n    )\n    builder.recordOperation((dataKey) =>\n      builder\n        .withEntity(() => new Entity())\n        .withEntityData(dataKey!)\n        .withSprite()\n        .withCircleCollider()\n        .withInsideBoxCollider()\n        .withRigidBody()\n        .withTransform()\n        .withBoxCollider()\n    )\n    return builder\n  }\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IManager,\n  IEntityDataModel,\n  IEntityManager,\n} from 'engine_api'\nimport BallBuilder from './BallBuilder'\nimport FootballGateBuilder from './FootballGateBuilder'\nimport SinglePlayerBuilder from './SinglePlayerBuilder'\nimport TileMapBuilder from './TileMapBuilder'\nimport GameStateBuilder from './GameStateBuilder'\nimport SpriteBuilder from './SpriteBuilder'\nimport { BuilderType } from './BuilderType'\n\nexport default class BuilderFactory {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  createBuilder(builderType: BuilderType) {\n    switch (builderType) {\n      case BuilderType.TileMap:\n        return new TileMapBuilder(\n          this._entityCreator,\n          this._entityDataManager,\n          this._entityManager\n        )\n      case BuilderType.FootballGate:\n        return new FootballGateBuilder(\n          this._entityCreator,\n          this._entityDataManager,\n          this._entityManager\n        )\n      case BuilderType.Football:\n        return new BallBuilder(\n          this._entityCreator,\n          this._entityDataManager,\n          this._entityManager\n        )\n      case BuilderType.SinglePlayer:\n        return new SinglePlayerBuilder(\n          this._entityCreator,\n          this._entityDataManager,\n          this._entityManager\n        )\n      case BuilderType.GameState:\n        return new GameStateBuilder(\n          this._entityCreator,\n          this._entityDataManager,\n          this._entityManager\n        )\n      case BuilderType.Sprite:\n        return new SpriteBuilder(\n          this._entityCreator,\n          this._entityDataManager,\n          this._entityManager\n        )\n      default:\n        throw new Error(`Invalid builder type: ${builderType}`)\n    }\n  }\n}\n```\n```typescript\nexport enum BuilderType {\n  TileMap,\n  FootballGate,\n  Football,\n  SinglePlayer,\n  GameState,\n  Sprite,\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityDataModel,\n  IEntityManager,\n  IManager,\n} from 'engine_api'\nimport EntityBuilder from '../EntityBuilder'\nimport ICustomEntityBuilder from './ICustomEntityBuilder'\nimport Entity from '../../../entity/Entity'\n\nexport default class FootballGateBuilder implements ICustomEntityBuilder {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  withCustomEntityBuilder(builderKey: string): void {\n    this._entityCreator.addBuilder(builderKey, this.getCustomEntityBuilder())\n  }\n\n  getCustomEntityBuilder(): EntityBuilder {\n    const builder = new EntityBuilder(\n      this._entityDataManager,\n      this._entityManager\n    )\n    builder.recordOperation((dataKey) => {\n      builder\n        .withEntity(() => new Entity())\n        .withEntityData(dataKey!)\n        .withSprite()\n        .withBoxCollider()\n        .withRigidBody()\n        .withTransform()\n        .withBoxCollider()\n        .withCollisionObject()\n    })\n    return builder\n  }\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityDataModel,\n  IEntityManager,\n  IManager,\n} from 'engine_api'\nimport EntityBuilder from '../EntityBuilder'\nimport ICustomEntityBuilder from './ICustomEntityBuilder'\nimport Entity from '../../../entity/Entity'\n\nexport default class GameStateBuilder implements ICustomEntityBuilder {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  withCustomEntityBuilder(builderKey: string) {\n    this._entityCreator.addBuilder(builderKey, this.getCustomEntityBuilder())\n  }\n\n  getCustomEntityBuilder() {\n    const builder = new EntityBuilder(\n      this._entityDataManager,\n      this._entityManager\n    )\n    builder.recordOperation((dataKey) => {\n      builder\n        .withEntity(() => new Entity())\n        .withEntityData(dataKey!)\n        .withGameState()\n    })\n    return builder\n  }\n}\n```\n```typescript\nimport EntityBuilder from '../EntityBuilder'\n\nexport default interface ICustomEntityBuilder {\n  withCustomEntityBuilder(customEntityBuilderKey: string): void\n  getCustomEntityBuilder(): EntityBuilder\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityDataModel,\n  IEntityManager,\n  IManager,\n} from 'engine_api'\nimport EntityBuilder from '../EntityBuilder'\nimport ICustomEntityBuilder from './ICustomEntityBuilder'\nimport Entity from '../../../entity/Entity'\n\nexport default class SinglePlayerBuilder implements ICustomEntityBuilder {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  withCustomEntityBuilder(builderKey: string) {\n    this._entityCreator.addBuilder(builderKey, this.getCustomEntityBuilder())\n  }\n\n  getCustomEntityBuilder() {\n    const builder = new EntityBuilder(\n      this._entityDataManager,\n      this._entityManager\n    )\n    builder.recordOperation((dataKey) =>\n      builder\n        .withEntity(() => new Entity())\n        .withEntityData(dataKey!)\n        .withSprite()\n        .withLimitMove()\n        .withRigidBody()\n        .withTransform()\n        .withBoxCollider()\n        .withCollisionObject()\n    )\n    return builder\n  }\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityDataModel,\n  IEntityManager,\n  IManager,\n} from 'engine_api'\nimport EntityBuilder from '../EntityBuilder'\nimport Entity from '../../../entity/Entity'\nimport ICustomEntityBuilder from './ICustomEntityBuilder'\n\nexport default class SpriteBuilder implements ICustomEntityBuilder {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  withCustomEntityBuilder(builderKey: string): void {\n    this._entityCreator.addBuilder(builderKey, this.getCustomEntityBuilder())\n  }\n\n  getCustomEntityBuilder(): EntityBuilder {\n    const builder = new EntityBuilder(\n      this._entityDataManager,\n      this._entityManager\n    )\n    builder.recordOperation((dataKey) => {\n      builder\n        .withEntity(() => new Entity())\n        .withEntityData(dataKey!)\n        .withTransform()\n        .withBoxCollider()\n        .withSprite()\n    })\n    return builder\n  }\n}\n```\n```typescript\nimport {\n  IEntityCreator,\n  IEntityDataModel,\n  IEntityManager,\n  IManager,\n} from 'engine_api'\nimport EntityBuilder from '../EntityBuilder'\nimport Entity from '../../../entity/Entity'\nimport ICustomEntityBuilder from './ICustomEntityBuilder'\n\nexport default class TileMapBuilder implements ICustomEntityBuilder {\n  constructor(\n    private readonly _entityCreator: IEntityCreator,\n    private readonly _entityDataManager: IManager<IEntityDataModel>,\n    private readonly _entityManager: IEntityManager\n  ) {}\n\n  withCustomEntityBuilder(builderKey: string) {\n    this._entityCreator.addBuilder(builderKey, this.getCustomEntityBuilder())\n  }\n\n  getCustomEntityBuilder() {\n    const builder = new EntityBuilder(\n      this._entityDataManager,\n      this._entityManager\n    )\n    builder.recordOperation(() => {\n      builder.withEntity(() => new Entity()).withMap()\n    })\n    return builder\n  }\n}\n```",
          "dateTime": "2024-02-15T19:49:07.698Z"
        }
      ]
    }
  ]
}